[{"content":"Problem In general blockchain, every single node is required to replicate, validate, store and maintain the states of all users in entire network.\nSolution This paper present a idea to divide the blockchain into different asynchronous consensus zones (multi-instanitiation of independent blockchain systems). Partitioning workloads of the entire network, distribute to zones. Parallelize blovk creation and transaction handling since we have multi-independent blockchain. To achieve linear scalability as the entire network is divided into more zones.\nBackground The system presented by this paper use Account/Balance transaction models and PoW. This paper uses the account/balance model due to its simplicity since a transaction with an arbitrary amount can be performed with one sending account and one receiving account. Another important benefit offered by the account/ballance model is allowing transactions to carry incremental updates of states, as oppose to the UTXO transactions that can only carry full states.\nSystem Design\rHandling a payment that involves two users from different zones example:\nThe withdraw oper\u0002ation ρ that only involves the state in zone A is handledby a miner in zone A. If the account balance satisfiesthe cost of this withdraw operation, the corresponding block t + 1 carrying the transaction (initiative transac\u0002tion) will be created by the miner and only be appendedto the chain of zone A. After that, a relay transactioncarrying the deposit operation φ is composed in zone Aand forwarded to zone B. The deposit operation φ thatonly involves the state in zone B can always be executed,regardless of the balance of the target account in zone B.Once the relay transaction is picked up by another minerin zone B, operation φ will be executed, concluding thecomplete of the payment transaction.\nPartitioning and Naming The account of user is represented by its address(a fix-sized hash value of its public key). Uniformly partitioning the space of user address into 2 power to k zones: a zone is identified by its sharding scale k and zone index s.\nThe zone index of an initiative transaction is determined by the payer\u0026rsquo;s address, and the zone index of a relay transaction is determinated by the payee\u0026rsquo;s address.\nIn the system of paper, full nodes join swarms to broadcast new transactions and receive blocks from other full nodes. A swarm is a group of nodes that participate in the replication of the same data set. For example, in Bitcoin or Ethereum, there is only one swarm and every full node replicates the same dataset, including all blocks and transactions. In the system of paper, there is a global swarm which joined by all full nodes for replicating the minimum common information of all zones. the most communication occurs in zone-specific swarm with full nodes belonging to specific zones only. In each swarm, the participating full nodes are sparsely connected, and use the gossip protocol to broadcast message.\nIsolated Intra-Zone Workload A full node, or a miner, will have a persistent identifier that is initialized randomly. With address space partitioning, a blockchain is established within each zone independently. Only care about their own zone! They should ignore any blocks or transactions received that do not belong to their zone(although those are unlikely to be received).\nMinimized Cross-Zone Overhead In a blockchain system, most communication is for replicating unconfirmed transactions and for broadcasting new blocks carring confirmed ones. But since now we have isolated zones, so the most communication is performed only among nodes within the zone. Each node maintain a DHT to help them find the specific zone for their peers. After getting the zone index s of an unconfirmed transaction or a forwarding block, system selects out nodes having the same zone index as s based on the lcoal DHT routing table, and it sends the transaction and block to these nodes following the gossip protocol. This way help to minimized data for chain forming excluding actual confirmed transactions are replicated across all zones (what is the actual confirmed transactions?)\nContribustion\nContribution Efficient Cross-Zone Atomicity Chaining-block a pointer to the precursor block\na PoW nonce\na Merkle tree root of the list of confirmed transactions\na Merkle tree root of the list of all relay transactions originated from initiative transactions in this block, which is used for the validation of relay transactions in other zones.\nDual-stage transaction handling mechanism By deriving and forwarding a relay transaction that carries the deposit operation to its destination zone.\nTransaction Validation and Forwarding at Zone A\nA miner pick up a unconfirmed transaction when they are constructing a new block.\nThe initiative transaction is validated if the balance of a is less than the transfer amount, this transactin wil be marked as invalid, and be concluded and embedded in the block.\nOtherwise, a chaining-block and a transaction-block are constructed. Transaction-block has a list of validated transactions including the one from a to b.\nThe miner work on the PoW puzzle specific to the list of all confirmed transactions.\nAfter the PoW puzzle is solved, the chaining-block is broadcast in the global swarm and the transaction-block is broadcast in a\u0026rsquo;s zone-specific swarm.\nWhen the other nodes wihtin this zone received the transaction-block, the intra-zone transactions are executed and concluded. The withdraw operation in all cross-zone transactions are then executed(on the other zones).\nEach cross-zone transaction derives an outbound relay transaction, which will be sent to the destination zone.\nRelay Transaction Handling at Zone B\nAn inbound relay transaction is picked up by a miner in payee b\u0026rsquo;s zone when constructing a new block.\nThe miner verifies the inbound relay transaction against its originate block. Skip this if invalid.\nThe miner constructed a new chaining-block and a new transaction-block including the inbound relay transaction.\nAs same as before the chaining-block will be broadcast in global swarm and the transaction-block will be broadcast in b\u0026rsquo;s zone after the PoW puzzle is solved.\nThe deposit operation is executed, concluding the transaction.\nVerification Let\u0026rsquo;s skip this part and regard it as a black box to use!!!\nEventual Atomicity A payment transaction involving withdraw and deposit operations, should be atomic to ensure corrrectness of the global ledger!!!\nRSCoin and OmniLedger use two-phase commit mechanism to ensure the atomicity, with the known lock/unlock overhead.\nIn this system, for a cross-zone trnsaction, allow the withdraw operation to execute first, then the the corresponding deposit operation to be settlled later. They call such an atomicity, eventual atomicity.\nTheir design ensures is that relay transactions will not be discriminated by sufficiently incentivizing with a fee split.\nfee split: incentivize both miners working on initial step and relayed step of transaction handling\nA rational miner prioritizes unconfirmed transactions based on the transaction fee. This paper introduce fee splitting for cross-zone transactions. The author recommend cross-zone transaction issuer set double or even triple the amount of transaction fees to make sure the relayed transactions can be prioritized with transaction fee after fee split.\nWe introduce fee splitting for cross-zone transactions,which incentivize both miners working on initial step andrelayed step of transaction handling so that relayed trans\u0002actions will be equally prioritized with transaction feesat similar levels 最后一句陈述的意思是处于similar level(worklaod 类似)的initial step of transactions和relayed step of transactions能够平等地根据transaction fee来区分优先级。\nIn the existing blockchain system, a payment transac\u0002tion will be visible to its payee once it is packed in ablock on the chain (first confirm). It will be secured aftern − 1 successive blocks appended (n-th confirm, n = 6in Bitcoin and 12 in Ethereum). In contrast, a cross\u0002zone payment transaction in our system will be visible to the payee, once its relay transaction is forwarded to thepayee’s zone, and its originate block becomes available.With the eventual atomicity, the transaction is consideredas eventually secured, once its initiative transaction gets n-confirmed, and the relay transaction gets a first confirm. (这一段是关于可见性的)\nFork Resolution Let\u0026rsquo;s skip this part!!!\nMining Power Diluted with Multiple Zones Skip this part now!\n[1] nsdi19-wang-jiaping.pdf (usenix.org)\n[2] Monoxide: Scale out Blockchains with Asynchronous Consensus Zones | USENIX\n","permalink":"/posts/read/monoxide/","summary":"Problem In general blockchain, every single node is required to replicate, validate, store and maintain the states of all users in entire network. Solution This paper present a idea to divide the blockchain into different asynchronous consensus zones (multi-instanitiation of independent blockchain systems). Partitioning workloads of the entire network, distribute to zones. Parallelize blovk creation and transaction handling since we have multi-independent blockchain. To achieve linear scalability as the entire","title":"Monoxide: Scale out Blockchains with Asynchronous Consensus Zones"},{"content":"Abstract \u0026ldquo;Scaling blockchain systems under general workloads remains an open question\u0026rdquo;.\nThe challenges of scaling are different between databasebases and blockchain since they have different failure models.\nThe major contribution of this paper:\nEnhance the performance of Byzantine consensus protocols -\u0026gt; inprove the individual shard\u0026rsquo;s throughput.\nDesign an efficient shard formation protocol -\u0026gt; leverage a trsted random beacon to securely assign nodes into shards.\nDesign a general distributed transaction protocol -\u0026gt; ensure safety and liveness even when transaction coordinators are malicious.\nIntroduction The tradeoff between strong security and scalability (the consensus protocol blockchain systems have to rely on is scalable poorly)\non hardware aspect -\u0026gt; \u0026ldquo;trusted hardware has not been demonstrated on data-intensive blockchain workloads\u0026rdquo;\nsharding -\u0026gt; divide the blockchain network into small committees to reduce the overhead of consensus protocols\nThis paper extend sharding to permissioned blockchian systems\nBFT consensus protocols in trusted execution environment(TEE) Leveraing trusted execution environment to eliminate equivocation(provide different values to its neighbors) in the Byzantine failure model -\u0026gt; achieve higher fault tolerance with the same number of nodes [(n-1)/3 - \u0026gt; (n-1)/2].\nNo necessary to understand too many details\nEfficient shard formation protocol Leverage the TEE to design an efficient and secure shard formation protocol -\u0026gt; implement a trusted randomness beacon inside the TEE to generate unbiased random values in a distributed setting\nThe nodes derive their committee assignment by computing a random permutation pi [1 : N] seeded by rnd. pi is then divided into approximately equally-sized chunks, each of which represents the members in one committee. To exploit TEEs to efficiently obtain rnd. Each new epoch correspondings to a new node-to-committee assignment, nodes invoke the enclave with an epoch number e to generate two random values q and rnd. If and only if q = 0. \u0026lt;e,rnd\u0026gt; is broadcasted to the network. After a time theta, nodes lock in the loweast rnd they receive for current epoch e, then use it to compute the committee assignment.\nNo necessary to understand too many details (Committee size, Shard Reconfiguration)\nUTXO transactions Consists of a list of inputs, and a list of outputs. All the inputs must be the outputs of previous transactions that are unspent. The outputs of the transaction are new, unspent coins. (Given a transaction, its inputs are unspent and the sum of the outputs is not greater than that of the inputs, if two transactions consume the same unspent coins, only one is accepted)\nDistributed transactions!!! RapidChain exploites UTXO model to achieve atomicity but can not achieve isolation. And it also fails to work for non-UTXO distributed transactions, because it violates both atomocity and isolation.\nOmniLedger achieves safety for the UTXO model but remain the liveness issue.\nThe design of this paper:\nDesign a distributed transaction protocol that achieves safety for general blockchain transactions (non-UTXO) and liveness against malicious coorinators\nSafety: two-phase commit (2PC) and two-phase locking (2PL)\nLiveness: To guard against a malicious coordinator -\u0026gt; BFT reference committee serve as a coordinator\nThe BFT reference committee is also a shard which formulated by a certain number of nodes.\nThe client initiates a transaction tx by sending BeginTX request to the reference committee.\nPrepare: Once R has executed the BeginTx request, in other words, the quorum of nodes in the R have reached the consensus on this request. it enters \u0026ldquo;Started\u0026rdquo; state. Nodes in R then send PrepareTx requests to the transaction committees(transaction shard). The tx-committee will wait for a quorum of matching PrepareTx to ensure that BeginTx has been executed in R. The each tx-committee executes the PrepareTx. If consensus is reached that tx can be committed, which requires that tx can obtain all of its locks I am really comfused about this statement???), the nodes within the committee send out PrepareOK messages.\nPre-Commit: When entering “Started” state, R initializes a counter c with the number of tx-committees involved in tx:\nreceiving the quorum of matching responses from a tx-committee it will maintain the same state or enter a new state depend on the state machine input (PrepareOK or PrepareNotOK). (I am really comfused about how to regard a committee as a state machine!!! How keep the consistancy between nodes? Which node in the committee to deciede there is a quorum of matching response?)\nCommit: Once R has entered \u0026ldquo;Committed\u0026rdquo; state, the nodes in R send out CommitTx or AbortTx message to tx-committees. As same as before, the latter wait for a quorum of matching messages from R before executing the corresponding commit or abort operation.\n2PC and 2PL 2PC (used for distributed transactions): Two-phase commit is an algorithm for achieving atomic transaction commit across multiple nodes \u0026ndash; to ensure that either all nodes commit or all nodes abort.\n2PL (used for consistency and isolation in stand-alone transactions): provides serializable isolation\nGrowing: request locks\nShrinking: free locks\ndatabases often use an enhanced version of S(trong)S(trict)2PL, which is a little different compared to 2PL: the shrinking phase, which can only release the lock after the transaction is over, completely eliminates the uncommitted data of the transaction from being read.\nHow to handle dead-lock?\nDeadlock detection: database system draw the wait-for graph, dead-lock happens if there is a ring.\nDeadlock prevention: as requesting a lock that is already held, the database system kills one of the transactions to prevent deadlocks (generally the longer the transaction lasts, the higher the priority of the reservation). This prevention method does not require a waits-for graph, but increases the rate at which transactions are killed.\nReference [1] Towards Scaling Blockchain Systems via Sharding (arxiv.org)\n[2] 区块链相关论文研读7：通过分片（Sharding）扩展区块链 - 知乎 (zhihu.com)\n[3] Introduction to two-phase commit, Don\u0026rsquo;t confuse 2PC and 2PL (ebrary.net)\n[4] 一篇讲透如何理解数据库并发控制（纯干货） - 知乎 (zhihu.com)\n","permalink":"/posts/read/sharding1/","summary":"Abstract \u0026ldquo;Scaling blockchain systems under general workloads remains an open question\u0026rdquo;. The challenges of scaling are different between databasebases and blockchain since they have different failure models. The major contribution of this paper: Enhance the performance of Byzantine consensus protocols -\u0026gt; inprove the individual shard\u0026rsquo;s throughput. Design an efficient shard formation protocol -\u0026gt; leverage a trsted random beacon to securely assign nodes into shards. Design a general distributed transaction protocol","title":"Towards Scaling Blockchain Systems via Sharding"}]