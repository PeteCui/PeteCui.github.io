[{"content":"Abstract WPaxos是一个多领导的Paxos协议，它可以在跨广域网的部署中提供低延迟和高吞吐的共识。WPaxos使用多个领导，在这些领导中划分object-space。不像静态划分的多Paxos部署，WPaxos能够适应不断变化的访问地点通过object stealing。多个同时存在于不同区域的领导人使用Paxos的第1阶段互相窃取对象的所有权，之后使用第2阶段在这些本地对象上提交更新请求指导他们被其他领导者窃取。为了实现快速的第二阶段提交，WPaxos采用了flexible quorum，并且差使二阶段的接受者靠近他们自己的领导者。\nIntroduction Paxos即使在异步情况下也不会违反Safety,当我们加入一些Synchrony条件后，分布式共识的实现成为可能。Paxos和它的变体被广泛部署和应用，但是这些实现都依赖于一个中心化的主进程去序列化所有命令。由于对主进程的依赖，这些Paxos实现们支持本地部署，但不能在跨广域网时应对写密集场景。但是跨广域网协调变得重要。\n要解决的问题：为了消除Paxos的单领导实现在跨WAN部署中带来的延迟瓶颈！，leaderless和multileader解决方案被提出。\nLeaderless: EPaxos是Paxos协议的一个无领导的扩展，任何区域的任何副本都可以投机地提出和提交命令，只要这些命令是无干扰的（挖个坑之后还得读这个！）但EPaxos要求约有3/4的接受者组成quorum,这意味着WAN延迟仍然会发生。而且，如果如果多个并发的投机的提议者提出相互干扰的指令，协议要求执行第二个阶段去记录所获得的依赖性，并且需要得到大多数的认可。\nMultileader: 另一个方式去消除单个领导者瓶颈是使用在每个zone中部署独立的Paxos组。一些系统比如Google Spanner\u0026hellip;使用的是全球的object-space的静态划分进不同的zones,每个领导者负责object-space的一个分片。然而这样的静态划分是不灵活的，在访问/更新映射到不同区域的object时，将持续产生广域网延迟。\n为了解决这个问题做出的贡献：提出WPaxos，一种多领导者Paxos协议在跨WAN部署中提供低延迟和高吞吐的共识\n利用flexible quorums去消减WAN通信的成本，以一种新颖的方式部署了flexible quorums，在广域网上任命多个并发的领导人。在这些multileader间划分object-space，将允许协议在不同并发的领导者处理对于object的请求。每个object维护他们自己的提交日志，从而允许per-object linearizability。通过有策略地选择第二阶段靠近领导的接受者。 WPaxos实现了快速提交决定。 在另一方面，WPaxos有区别于现在的静态划分的多Paxos部署解决方案，因为它实现了一个动态的划分方案： 在不同区域的领导者使用Paxos的第一阶段从对方那里窃取一个对象的所有权/领导权，然后使用第二阶段在本地提交对象的更新请求，直到该对象被另一个领导者窃取。\nRelated Work 文章对Paxos协议家族进行了根据建筑学进行的分类：\n1. 单领导协议： Multi-Paxos和Raft依赖单个节点去推动进步\n2. 多领导协议： 不是所有命令都要求在系统中存在一个total order，多领导算法可以在不同的领导处并行地运行许多指令，只要这些命令属于不同的冲突域。这也使得每个领导者节点通常也作为另外一个conflict domain的接受者不能提供全序，但可以在同一个conflict domain中提供偏全序\n3. 多领导，多quorum协议: WPaxos更进一步，允许不同的领导者使用不同的quorum,只要quorum内部的通信能保证要求的安全属性\n分层的多领导协议： 高阶领导者监督和协调低阶的孩子领导者，master quorum负责与children quorum不同的工作。\n4. 无领导协议： 不在节点间强加conflict domains的划分，而是投机地提交任何命令在任何节点。任何节点在EPaxos中都能为一个命令成为一个投机的领导者，并且通过在一个fast quorum system中运行一个两阶段Paxos去尝试提交它。如果一些其他节点在fast quorum中也正在尝试提交一个冲突的命令，那么一个额外轮次的通信被用来为冲突的命令排序。\nWPaxos Overview 假设有一组节点通过消息传递进行通信。节点被部署在一组zone中，zone是可用隔离单元。每个节点维护一系列根据递增slot number排序的instance。每个instance与一个ballot号码一起进行提交。每个ballot有一个独特的领导，且是由整数和其领导标识符组成的pair。因此，选票号码是唯一的，而且是完全有序的，任何节点都可以很容易地从给定的选票中检索到领导者的id。\nWPaxos Quorums WPaxos使用了flexible quorums的主意。这一结果表明，我们可以将Paxos的 \u0026ldquo;所有的quorum都应该相交 \u0026ldquo;的断言弱化为 \u0026ldquo;只有来自不同阶段的quorum应该相交\u0026rdquo; 如果第一阶段的quorum与第二阶段的quorum相交，那么majority quorum不是必须的。假设失败和领导者的改变是罕见的，那么负责告诉接受者决定值得第二阶段将会比第一阶段更频繁，因此通过减小phase2的quorum size来提升性能，为此付出的代价是将phase 1的quorum size增大。\n定义1： 一组节点上的quorum系统是安全的，如果用于phase1和phase2的quorum是相交的\nWPaxos在WAN的部署中采用了flexible quorums的主意。采用grid quorum layout，好处是Q1+Q2不需要超过N, (在flexible quorum里是需要超过N的）\n每一列代表一个zone（一个可用单元或者地理隔离）所有zone的集合组成一个grid。\n我们引入两个新变量：\nf_z系统可以容忍的zone故障数量\nf_n一个zone失去可用性前可以容忍的节点故障数量\n为了在每个zone中容忍f_n个崩溃故障，WPaxos在l个节点中挑选f_n+1个节点。除此以外，为了在z个zones中容忍f_z个的zone故障，phase-1的quorum从（z - f_z）中选取，phase-2的quorum从（f_z + 1）个zone中选取。这可以保证Q1和Q2总是有交集。\n这个图是WPaxos的一个部署例子，我们可以看到提高了容错，因为在之前的部署中如果一个zone中有节点故障，我们就不能收集足够的vote，代价是需要收到的vote数量也增加了。\nMulti-leader WPaxos基于flexible quorums上提出了多领导协议。WPaxos中的每个节点都能成为一部分object的领导者，这允许协议并行地处理对属于不同领导者的object的请求\nWPaxos协议由两个阶段组成：\nPhase1 并发的领导者stealQ1中的object的所有权/领导权\nPhase2 提交更新请求到Q2的object\nphase1只有当节点需要从远端领导者steal一个object或者客户有一个对于不在系统中的全新object的请求时才会执行。该算法的这一阶段会使所涉及的对象的ballot增长。当一个节点成为object的拥有者时，它可以多次执行phase2来提交指令和更新，在每次迭代中增加slot数字，但是保持对象的ballot不变。\nObject Stealing 当一个节点为了执行用户的请求需要从另一个领导者steal一个object时，它首先需要先咨询它的内部ca这个object最后使用的ballot number以及用一个更大的ballot执行phase1。对象窃取是成功的，如果候选节点能够out-ballot当前的节点。只要本地缓存是最新的，并且远程领导没有在同一obejct上进行另一个phase1，那么我们只需要一次尝试。\n一旦object被盗，老领导者就不能再对它进行任何操作了。object被盗可能发生在object的一些命令仍在进行中的时候，因此，新的领导者必须恢复任何已接受的，但尚未提交的命令。\nWPaxos为所有object维护独立的ballot，以隔离object偷窃的影响。保留每个领导者的ballot，即为领导者维护的所有object保留一个ballot，在试图窃取一个ballot时，将需要投票出远程领导者的所有object(这里没太懂)，这会造成决斗，这么做可以减轻决斗，虽然不可避免。还补充了两个方法减轻决斗1.发生ballot冲突时通过nodeID和zoneIDj解决。2.发生决斗时REB。\nWPaxos Algorithm 每个节点维护一组变量和在log中写入的一系列指令，指令能够允许失序提交，但是在状态机上的执行必须使同一个顺序，每个指令仅仅接触一个object，每个节点维护一个它自己领导的对象集合叫做own。Ballot由计数器和节点ID组成；slot初始为0；拥有的object初始化为空；一个log实例包含一下信息：ballot，proposed value和一个flag标志这个实例是否已经被提交了。\nPhase-1: Prepare 当接收到用户的请求时，节点会检查是否object存在在自己的own集合中，如果没有，执行p1a()，如果已经存在则可以直接执行phase-2。在p1a()中，一个更大的ballot被选择并且这个\u0026quot;1a\u0026quot;消息被发送到Q1 quorum。\np1b()负责处理收到的1a，一个节点能够接受一个发送者作为object o的领导，当且仅当这个发送者的object的ballot等于或大于自己已知ballot；如果这个object属于当前节点，哪么还要将这个object从own中移除。最后发回的1b中还要附带关于object的最高ballot，帮助新领导者提交所有为解决的命令。\nPhase-2: Accept 当完成Phase1，或者确定无需对给定的object进行Phase1后，WPaxos可以对就近的F+1个zones执行Phase2。\np2a()中收集1b消息，当Q1 quorum满足时节点成为新领导。新领导使用建议的值恢复所有未提交的slot，并且通过增加最高的slot为自己pending的请求值开始Phase2，同时在log中创建一个新的entry,之后发送2a消息。\np2b中，接受者收到2a消息后在检查了ballot以后，更新log中2a消息中对应的slot。之后发回2b消息给领导者。\nPhase-3: Commit 领导在从Q2的接受者处收集了回复后。请求要么在满足了Q2 quorum的情况下被提交了，要么在有一些接受者以收到了更高的ballot为由拒绝提议而被舍弃了。在被拒绝的情况下，节点会更新本地ballot，并将该slot中的实例请求放回主请求队列，以便 稍后重试\n[1] https://zhuanlan.zhihu.com/p/32757145\n[2] https://arxiv.org/pdf/1703.08905.pdf\n","permalink":"/posts/read/wpaxos/","summary":"Abstract WPaxos是一个多领导的Paxos协议，它可以在跨广域网的部署中提供低延迟和高吞吐的共识。WPaxos使用多个领导，在这些领导中划分ob","title":"WPaxos: Wide Area Network Flexible Consensus"},{"content":"Abstract Zyzzyva是一种使用投机来降低成本并简化拜占庭容错状态机复制设计的协议。在 Zyzzyva 中，副本响应客户端的请求，而无需首先运行昂贵的三阶段提交协议来就必须处理请求的顺序达成一致。相反，他们乐观地采纳primary提出的命令并立即响应客户。因此，副本可能会暂时彼此不一致，但客户端会检测到不一致，帮助正确的副本收敛于请求的一种全序，并且仅依赖于与该全序一致的响应。这种方法使Zyzzyva能够将复制的开销减少到接近理论上的最小值。\n1. Introduction 三个趋势吸引BFT的实际部署：\n数据不断提升的价值和越来越便宜的硬件成本，服务提供商用越来越不昂贵的硬件换取BFT部署带来的安心是值得的。\n在实际系统中，越来越多的non-fail-stop的证据表明，即使不采用n-version programming，BFT也可能产生显著的好处。(不懂这个)\n对BFT复制技术现状的改进，通过缩小BFT复制成本与非BFT复制的已支付成本之间的差距，使BFT复制越来越实用。\nZyzzyva, 一个新的协议，使用投机来减少成本并简化BFT状态机复制的设计。如同传统的状态机复制协议，一个primary对其他副本关于来自客户的请求提出一个顺序。在Zyzzyva中，不像传统的协议，副本投机性地执行请求而无需运行昂贵的协定协议(agreement protocol)去确定性地建立顺序。作为结果，正确的副本状态可能会分岔，副本也可能发送不同的响应给客户端。然而，客户端的应用程序观察复制状态机的传统和强大的抽象，该状态机以线性的顺序执行请求，因为回复带有足够的历史信息，供客户确定回复和历史是否stable并保证最终提交。如果投机的回复和历史stable，则客户端使用回复。否则的话，客户等待直到系统收敛到一个stable回复和历史。（回复：reply; 历史：histoty）\nZyzzyva 面临的挑战是确保对正确客户端的响应变得稳定。最终，副本负责确保所有来自正确的客户端的请求最终完成，但等待回复和历史变得稳定的客户端可以通过提供信息来加速这一过程，这些信息将导致请求在当前视图中迅速变得稳定，或者触发视图的变化。请注意，由于客户端不要求请求提交，只要求请求变得稳定，所以客户端对请求的行动只需要一到两个阶段，而不是习惯上的三个阶段。从本质上讲，Zyzzyva 重新考虑了 BFT 的同步：我们不是悲观地确保副本在与客户端通信之前就请求建立最终顺序，而是将输出提交移至客户端。以这种方式利用客户能提供重大的实际优势。 与PBFT在内的一些协议比较，对于要求苛刻的工作负载，Zyzzyva 减少了加密开销并将峰值吞吐量提高了两倍。事实上，Zyzzyva的复制成本、处理开销和通信延迟接近其理论下限。\n2. System Model 我们假设拜占庭故障模型，其中故障节点（副本或客户端）可能会任意行为。我们假设有一个强大的对手可以协调故障节点来破坏复制的服务。然而，我们确实假设对手无法破解密码技术，如抗碰撞散列、加密和签名。我们的系统确保其最多 f个副本的liveness和safety属性出现故障。我们假设客户端数量有限，其中任何数量都可能有故障。\n我们的系统的safety性质在任何异步的分布式系统中。其中节点通过网络连接，可能无法传递消息、损坏消息、延迟消息或乱序传递。然而，Liveness仅在发送到正确节点的消息在从发送消息时起的某个固定（但可能未知）的最坏情况延迟内得到处理的间隔期间才能确保活性。\n我们的系统使用状态机复制实现 BFT 服务。传统的状态机复制技术只能应用于确定性服务。我们通过在副本上抽象可观察的应用程序状态并使用协议阶段来解决分歧来应对许多实际应用程序（例如文件系统和数据库）中存在的不确定性。服务通过对客户端进行身份验证、强制访问控制以拒绝客户端访问他们无权访问的对象，以及（可选地）维护共享数据的多个版本（例如，文件系统中的快照，以便如果有故障的客户端破坏了数据，可以从旧版本中恢复数据。\n3. Protocol Zyzzyva 是一种基于三个子协议的状态机复制协议：(1) agreement，(2) view change，和 (3) checkpoint。 agreement协议对副本要执行的请求请进排序。当前primary出现故障或系统运行缓慢时，view change协议会协调新primary的选举。check point协议限制了副本必须存储的状态，并降低了view change的成本。\nPrinciples and Challenges Zyzzyva关注客户端观察到的safety性质。在Zyzzyva中，副本变的短暂地与其他副本不一致，但是客户可以检测到不一致，并且驱使副本收敛到一个请求的全序上，并且仅依赖于与该全序一致的响应。\n鉴于一些BFT 复制协议已经赋予过客户端的职责，所以将输出提交完全移至客户端并不是一大步，但这一小步带来了巨大的回报。首先，Zyzzyva利用投机的执行——副本在它的顺序被完全建立之前执行一个请求。第二，Zyzzyva利用fast agreement protocol在最少三个消息延迟内建立请求排序。第三，一旦客户端知道请求的顺序，agreement sub-protocol就会停止处理请求，从而避免在副本上建立此知识所需的工作。\n这为Zyzzyva的设计带来了两个关键挑战。首先，我们必须仔细指定请求在客户端完成的条件，并且定义agreement, checkpoint, 和 view change子协议以保持请求在单个正确状态机上执行的抽象。直观地说，当正确的客户端可以安全地对请求的回复采取行动时，请求就完成了。 为了帮助客户端确定何时适合对回复进行操作，Zyzzyva 将历史信息附加到客户端收到的回复中，以便客户端可以判断回复是否基于相同的请求顺序。 Zyzzyva 确保以下安全条件：\nSAF： 如果序列号为 n 且历史记录为 h_n 的请求完成，则任何以更高序列号 n\u0026rsquo; ≥ n 完成的请求都具有包含 h_n 作为前缀的历史记录 hn\u0026rsquo;。\n第二， view change子协议必须确保活跃性，尽管agreement子协议在view期间从不需要超过两个阶段来完成。我们将这一工作从agreement子协议转移到view change子协议通过引入一个新的“I hate the primary”阶段来保证一个正确的副本仅仅放弃当前视图，如果它可以确保所有其他正确的副本都将加入叛变。Zyzzyva在eventual synchrony的条件下确保以下liveness：\nLIV：由正确的客户端发出的任何请求最终都会完成。\nProtocol Overview Zyzzyva被3f + 1个副本执行，同时执行被组织成一系列视图（views）。在一个视图(view)内，一个单独的副本被设计成primary负责领导agreement子协议。\nFast agreement sub-protocol\n客户端发送请求给primary, primary转发请求给副本，同时副本执行请求并发送他们的回复给客户端。请求以两种方式之一在客户端完成。首先，如果客户端收到3f+1个相互一致的回复（包括一个applicaiton-level的reply和它所依赖的history), 之后客户端认为请求完成并基于它做下一步操作。第二，如果客户端收到[2f+1, 3f]个相互一致的请求，那么客户端聚集2f+1个回复。同时分发这个commit certificate给副本们。一旦2f+1个副本承认收到一个commit certificate,那么客户认为这个请求被完成并基于它做下一步操作。\n(如果有足够数量的副本怀疑当前主节点有故障，则发生视图更改并选举新的主节点。)\n3.1 Node State and Checkpoint Protocol 每个副本i维护一个已经执行了的有序的请求的history和副本i见过的覆盖最多副本i储存的历史前缀的max commit certificate的拷贝。History直到并包括max commit certificate所涵盖的具有最高序列号的请求的history是committed history，之后的历史是speculative history。如果 n 是committed history中任何请求的最高序列号，我们就说提交证书的序列号为 n。\n一个副本每CP_INTERVAL次请求构造一个checkpoint。一个副本维护一个stable checkpoint和一个与之对应的stable application state snapshot, 它可能最多储存一个tentative checkpoint和与之对应的tentative application state snapshot。tentative checkpoint点和application state的过程类似于早期 BFT 协议使用的过程。（不太清楚这里，挖个坑，作者在他们的extended report里讨论了这个问题）。做个总结：当一个正确的副本产生一个tentative checkpoint，它发送一个签名的CHECKPOINT消息给所有副本。 消息包括checkpoint里任何请求的最高序列号，以及一个关于检查点的digest和application snapshot。一个正确的Zyzzyva副本认为checkpoint和对应的application snapshot是stable的，当它收到f+1个被不同副本签名的匹配的CHECKPOINT消息\n为了限制History的大小，一个副本（1）截断committed checkpoint前的history.（2）封锁新请求的处理，当从committed checkpoint起，处理了2xCP_INTERVAL 个请求。\n最后，每个副本维护一个response cache，其中包含来自每个客户端的最新有序请求的副本以及相应的响应。\n3.2 Agreement Protocol 图片1说明了一个在一个视图中agreement sub-protocol的基本流程。因为副本在不与其他副本通信的情况下按照主提议的顺序投机地执行请求，关键挑战是确保客户端仅对以全序执行的稳定请求的回复做出行动，并且这些请求保证最终在所有正确的服务器上被提交。要么收到3f+1个匹配的回复；要么从2f+1个副本收到他们对于收到了commit certificate的acknowledgements. 这两个条件中的任何一个都可以证明具有相同的序列号和客户端观察到的先前请求的历史记录的请求最终将在所有正确的副本上提交。\n为了描述系统如何处理——丢失的消息、有故障的主服务器、有故障的客户端等。我们通过在系统中跟踪一个请求，定义服务器用来处理每条消息的规则。\n这里我省略对于消息内参数的介绍，不是因为我懒，是因为markdown不好打奇奇怪怪的符号，直接看原paper比较好\nClient sends request to the primary. 客户端 c 通过向它认为是主要副本（即客户端收到的最后一个响应的主要副本）发送消息来请求复制服务执行操作 o。\nPrimary receives request, assigns sequence number, and forwards ordered request to replicas. 当primary从客户端收到消息，它会给这个消息在当前视图下分配一个序列号并且转发这个新消息给backup replicas。\nReplica receives ordered request, speculatively executes it, and responds to the client. 在收到来自primary的ordered request。副本i接受这个ordered request，如果这个消息是一个良好构造的REQUEST消息。在接受消息后，i将这个排序好的请求添加到它的历史，在当前应用状态上执行这个请求并产生一个回复r，并把它发回给客户端。\nClient gathers speculative responses. 客户端收集来自副本的回复。有四种情况需要考虑\n4a Client receives 3f+1 matching responses and completes the request.\n在没有故障的情况下，客户端从所有3f+1个副本收到匹配的回复消息。然后客户端认为请求及其历史是完整的，并将回复 r 传递给应用程序。Zyzzyva 保证即使视图发生变化，所有正确的副本也将始终在其历史记录中的此时执行此请求以产生此响应。 请注意，尽管客户端有证据证明请求在历史记录中的位置是不可撤销的，但没有服务器有这样的证据。 实际上，此时服务器无法确定请求是否已按其最终顺序完成，或者因为有故障的主服务器对请求的排序在副本之间不一致而有必要回滚服务器状态。\n4b Client receives between 2f + 1 and 3f matching responses, assembles a commit certificate, and transmits the commit certificate to the replicas.\n如果网络，primary，和一些副本是故障的，那么客户端可能永远无法收到所有的3f + 1个回复。因此客户端会在第一次发出这个请求时设置一个timer，如果当计时超时，如果客户端从[2f+1,3f]收到匹配的投机回复，那么客户端发送一个包含commit certificate的COMMIT消息。 commit certificate由 2f + 1 个副本的列表，来自这些副本的 2f + 1 个匹配的回复中的副本签名部分以及相应的 2f + 1 个副本签名组成。\n4b.1 Replica receives a COMMIT message from a client containing a commit certificate and acknowledges with a LOCAL-COMMIT message.\n当一个副本i收到包含一个有效的commit certificate的COMMIT消息（这个消息证明一个请求应在当前视图中使用指定的序列号和历史记录执行请求）首先副本会先确定本地history与commit certificate中的一致。如果是的话，副本i (1)如果此证书的序列号高于存储的证书的序列号，则更新自己的max commit certificate状态；(2) 发送一个LOCAL-COMMIT给客户端。\n4b.2 Client receives a LOCAL-COMMIT messages from 2f + 1 replicas and completes the request.\n客户端重新发送COMMIT消息，直到它从 2f + 1 个不同的副本接收到相应的LOCAL-COMMIT消息。 然后客户端认为请求及其历史是complete的，并将回复 r 传递给应用程序。 系统保证即使视图发生变化，所有正确的副本也将始终在其历史记录中的此时执行此请求以产生此响应。\n4c. Client receives fewer than 2f + 1 matching SPEC-RESPONSE messages and resends its request to all replicas, which forward the request to the primary inorder to ensure the request is assigned a sequencenumber and eventually executed.\nClient 如果网络或者主节点出现故障，那么客户端将永远无法从2f+1个副本收集到匹配的SPEC-RESPONSE消息。因此，客户端在第一次发出请求时设置第二个计时器，并在第二个计时器到期时重新向所有副本发送请求消息。 然后它会重置计时器并继续收集推测性响应。\nReplica 当一个non-primary副本i从一个客户端收到请求消息，这里有两种副本i可能会采取的行动。（1）如果请求与客户端当前缓存请求匹配或具有比客户端当前缓存请求更低的客户端提供的时间戳，则副本i将缓存的响应重新发送到客户端。（2）如果请求有比客户端当前缓存请求更高的时间戳，那么副本i发送一个CONFIRM-REQ请求给当前的primary并设置一个计时器，如果副本在计时器到期前收到对于这个CONFIRM-REQ请求的ORDER-REQ消息，那么它将投机性地执行这个请求，否则的话，它将发起一个view change请求。\nPrimary 取决于从副本i收到的CONFIRM-REQ请求，primary首先检查时间戳。 如果请求是新的，primary如步骤 2 中所述使用下一个序列号来发送一个新的ORDER-REQ消息。否则，发送给副本i来自客户端的最新的缓存的ORDER-REQ请求消息。\n4d. Client receives responses indicating inconsistentordering by the primary and sends a proof of misbehavior to the replicas, which initiate a view change tooust the faulty primary.\n如果客户端收到一组对于同一个请求的包含有效ORDER-REQ，但序列号不同的SPEC-RESPONSE消息。那么这就是primary有misbehavior的证明（POM）。客户端会广播这些消息给副本。根据收到的POM，一个副本会发起view change,并转发POM给所有的其他副本。\n请注意，情况 4b 和 4c 并不排除 4d； 客户端可能会收到足以完成请求或形成提交证书的消息，以及针对主节点的不当行为的证明。\n3.3 View Changes Fast agreement和投机执行对Zyzzyva的view change 子协议有深刻的影响。view change子协议必须选举一个新的primary并且保证它不会改变已经在正确的客户端完成的历史。为了保持safety性质，传统的view change子协议要求一个提交视图更改请求的正确副本停止接受CHECKPOINT、VIEW-CHANGE和NEW-VIEW消息以外的消息。同时为了防止故障的副本扰乱系统，一个view change子协议应该从未移除一个primary,除非至少一个正确的副本提交了view change，如果 (a) 它观察到primary有故障或 (b) 它有 f + 1 个副本已提交view change的证据。在提交view change时，正确的副本会发送已签名的VIEW-CHANGE消息，这个消息包括新的视图，副本最新stable检查点的序列号(附带稳定证明)，一组prepare certificate——与commit certification等同。\n当新primary使用来自不同副本的 2f + 1 条VIEW-CHANGE消息计算所有正确副本必须采用以进入新视图的请求历史时，传统视图更改完成。 新primary将此历史和有效性证明包含在它向所有副本广播的已签名NEW-VIEW消息中。\nZyzzyva 保持了传统协议的整体结构，但它在两个重要方面有所不同，它们共同允许客户端在任何副本知道请求已提交之前接受响应，并允许副本在两个阶段后提交响应，而不是传统的三个阶段。\n首先，为了确保活跃度，Zyzzyva 通过向view change子协议添加一个新的““I hate the primary”阶段来加强正确副本提交view change的条件。 我们通过考虑The Case of the Missing Phase来解释此添加的必要性和详细信息。 其次，为了保证安全，Zyzzyva 弱化了请求出现在NEW-VIEW消息所包含的历史中的条件。 我们通过考虑The Case of the Uncommitted Request来解释此更改的必要性和详细信息。 3.3.1 The Case of the Missing Phase 如果我们观察一个正确的客户端执行4b步骤，并且在副本间实现一个广播信道，我们会发现Zyzzyva的通信模式只能map到PBFT三个阶段中的两个阶段。\n第二个问题的答案在于协议和视图更改子协议之间的微妙依赖关系。 没有使用传统view change协议的复制服务能够在没有包含prepare和commit full exchange的agreement协议下运行。考虑以下Zyzzyva情景，假设我们有f个故障副本，他们中的一个是primary，并假设故障的primary导致f个正确的副本提交了一个视图更改请求并且停止在当前视图下发送消息。在这种情况下，一个客户端请求可能只能从剩下的正确副本收集到f+1个回复，不足以让请求在第一阶段或第二阶段完成——而且，因为少于 f+1副本要求视图更改，所以 没有机会通过选举新的 primary 来恢复活力。\n传统BFT agreement的第三个阶段打破了这一僵局：通过交换他们所知道的，剩下的f+1个正确的副本可以在仅收到 f+1个匹配回复后收集完成请求所需的证据，或者确定视图更改是必要的。\n回到之前的问题，Zyzzyva是如何避免agreement子协议中的第三阶段呢? 在之前的场景中，影响活性是因为传统的view change协议让正确的副本提交视图更改请求后要在这个视图中保持沉默，而不保证它们的操作会导致视图更改。 而在Zyzzyva中，一个正确的副本不会放弃视图v，除非它保证每个其他正确的副本都会做同样的事情，从而强制一个新的视图和一个新的primary\n为了确保这个性质，Zyzzyva的view change子协议添加了一个额外的阶段来强化副本停止参与当前视图的条件。一个怀疑视图v的primary正确的副本i，会继续参与当前视图，但是表达它不信任的投票通过广播一个I-HATE-THE-PRIMARY消息给所有的副本。如果i收到f+1个对于v的primary不信任的投票，那么它就会提交一个view change:它会沉默，并且广播给所有副本一个包括f+1个不信任投票的证明的VIEW-CHANGE消息。一个正确的副本收到有效的VIEW-CHANGE消息会加入兵变同时提交view-change。Zyzzyva的view change子协议确保如果一个正确的副本在视图v提交了一个view change，最终所有的正确节点也会提交因为其他正确的节点收到后会立刻加入兵变。 实际上，Zyzzyva 将处理故障primary所需的成本从关键路径（协议协议）转移到view change子协议，该子协议仅在主节点出现故障时运行。将之前在agreement子协议中为view change服务的广播阶段转移到view change子协议中。\n3.3.2 The Case of the Uncommitted Request Zyzzyva的副本们可能从未学习到agreement协议的结果：当一个请求被完成时只有客户端可能知道。Zyzzyva副本怎样定义一个新视图的安全的历史前缀？\n在 Zyzzyva 中可以通过两种方式完成请求r及其历史记录。我们先从视图变化的角度考虑问题最少的：它发生在当一个客户端收到2f+1个LOCAL-COMMIT消息，一个请求r完成。这意味着至少f+1个正确的副本现在已经为请求r储存了一个commit certificate. 传统的view change协议已经能够处理这种情况：一个标准的包括所有从最新的stable checkpoint开始的commit certificate的VIEW-CHANGE消息被一个正确的副本发送。新的primary在NEW-VIEW消息中包含所有出现在它收到的任何 2f+1VIEW-CHANGE消息中的commit certificate， 那么至少一个VIEW-CHANGE 消息一定包含一个r的commit certificate. （在客户端处收到2f+1个LOCAL-COMMIT消息的r，它的commit certificate一定出现在2f+1个VIEW-CHANGE消息中）\n第二种情况更具有挑战：如果r的完成是因为客户端收到3f+1个匹配的投机回复，那么没有正确的副本会有r的commit certificate。我们处理这种情况通过用两种方式修改view change子协议。第一，正确的副本将从最新的stable checkpoint起收到的所有ORDER-REQ消息或commit certificate添加到VIEW-CHANGE消息中。第二，一个正确的新primary在新视图中要采用的历史记录被扩展，包括所有序列号高于任何最大的commit certificate序列号，且出现在新primary收集到的2f+1个view-change消息的f+1个中的ORDER-REQ消息的请求。\n此更改削弱了在一个视图中排好序的请求可以出现在新视图中的条件：我们不再需要commit certificate，但也允许足够数量的ORDER-REQ消息来支持请求的排序。 此更改可确保协议继续履行在客户端收集到3f+1个匹配的投机的回复时完成的任何请求的排序承诺。\n请注意，此更改可能会产生将序列号分配给在先前视图中尚未完成的请求的副作用。（收到了f+1个ORDER-REQ,但没有被完成） 特别是，该协议的一个奇怪之处在于，根据primary使用的 2f+1个VIEW-CHANGE消息集，对于给定的序列号，它可能会找到具有f+1个ORDER-REQ消息的不同请求。 然而，这种奇怪是良性的，不会导致系统违反安全性。 特别是，只有在至少一个正确的副本支持每个候选请求的情况下，才会有两个候选请求有相同的序列号。 在这种情况下，如果让客户端接收到3f+1个匹配的响应，则两个候选人都无法完成，系统可以安全地将其中一个（或都不）请求分配给此序列号。（什么情况下出现会这种情况我还没想出来）\n[1] http://www.cs.cornell.edu/lorenzo/papers/kotla07Zyzzyva.pdf\n","permalink":"/posts/read/zyzzyva/","summary":"Abstract Zyzzyva是一种使用投机来降低成本并简化拜占庭容错状态机复制设计的协议。在 Zyzzyva 中，副本响应客户端的请求，而无需首先运行昂贵的三阶段提交协","title":"Zyzzyva: Speculative Byzantine Fault Tolerance"},{"content":"My notes for video of ICDE2020 tutorial4.\n","permalink":"/posts/tech/icde_tutotial4a/","summary":"My notes for video of ICDE2020 tutorial4.","title":"Modern Large-Scale Data Management Systems after 40 Years of Consensus"},{"content":"之前对于Byzantine Paxos的理解完全建立在Youtube上Mu Shuai老师的讲解视频上，现在决定好好读一遍Lamport老爷爷的原论文并记一下笔记！\nAbstract 我们通过拜占庭化一个普通的Paxos算法推导出一个3f+1进程的拜占庭Paxos共识算法。其中2f+1个nonfaulty进程模仿常规的Paxos算法，同时有f个恶意的进程。\n1. Introduction Paxos算法已经成为一个标准工具去实现一个容错的分布式系统。它使用2f+1个进程去容忍可能出现的f个良性故障。Castro和Liskov开发了一个3f+1进程的算法（PBFT）去容忍拜占庭节点。他们的算法看起来是一个拜占庭版本的Paxos,之后其他一些看起来是拜占庭版本的Paxos也相继出现。\n我们使用一个叫做Byzantizing的更直接的方式将一个分布式的非拜占庭算法推导得到一个拜占庭Paxos算法，Byzantizing 将一个能够容忍最多f个良性故障 N 进程算法转换为一个能够容忍 f 个拜占庭进程的 N+f 进程算法。在被拜占庭化后的算法中，N 个良好的进程模仿原始算法的执行。\n原始算法和拜占庭算法的心脏部分是共识算法。我们拜占庭化一个经典Paxos共识算法的变体，我们称它为PCon。同时将PBFT的抽象概括称为BPCon。\n2. Consensus and Classic Paxos 我们假设通常的异步进程分布式计算模型通过消息传递进行通信。良性的失败指消息的丢失和进程停止。一个拜占庭进程可能发送任何信息，但是我们假设接收者可以确定信息的发送者，这可以通过点对点通信实现或者message authenticators(MACs)\n2.1 Consensus 在一个完备的共识规范中，提议者发起提议，一组接收者一起选择提议值中的一个值，而学习者进程了解什么提议值（如果有的话）已经被选择。共识算法必须容忍一定数量 f 的接受者失败，以及任何提议者或学习者的失败。\n简单起见，我们不考虑提议者和学习者，只考虑接受者。我们关于什么值被选择的定义使如何实现“learning”变得清晰。在Byzantine条件下实现提议者不是容易的，因为我们要防止拜占庭节点伪装成无故障的提议者，但是Castro和Liskov已经解释了如何实现它通过使用数字签名和MACs。通过这种简化，共识的规范由一个平凡的算法组成，其中接受者最多可以选择一个值，但一旦选择了一个值，就必须永远保持选择状态。\n众所周知，容错共识算法不能在纯异步系统中实现。我们要求安全性质成立即使我们没有任何同步假设，而活性属性则在我们有一些同步假设的情况下在无故障进程上成立。\n2.2 Paxos Consensus 简单介绍了一下Paxos\nN：接收者的数量，N必然需要大于f\nquorum: 任何 N-f 个接收者。\n为了实现安全性我们需要任何两个quorum有一个非空的交集，那么 N \u0026gt; 2f ，比如N = 2f+1 ，那么quorum就是 f+1，在N中任意取两组数量为f+1的接收者，两组中一定有至少一个共同的正确进程。另一个关于quorum的性质是我们需要至少有一组quorum完全由无故障的进程组成，这是为了满足活性（理解很简单，因为如果没有这样的quorum存在，那么拜占庭节点可以一直通过无响应来永久的地阻止共识算法取得进展）\n一个接收者在一个ballot下可以最多给一个值投票。一个值在一个ballot下被选择，当且仅当一组法定人数的接收者已经在这个ballot下为这个值进行了投票。\n我们说这个值在一个ballot number下是安全的，如果没有其他值在一个比当前ballot number小的ballot number下被选择或者曾经能够被选择\n该算法保持以下属性\nP1. 一个接收者只有当 v 在ballot b 是安全的，才能够在ballot b 给一个value v 投票\nP2. 不同的接收者不能在相同的ballot下给不同的值投票\n这些性质通过一个ballot b的领导者选择一个在ballot b 下安全的value v以及邀请接收者在ballot b下为这个值投票。一个接收者只有在接受到这样的请求时才会进行投票（当且仅当还没有对任何更高的ballot进行操作）一个ballot b有两个阶段需要进行。\nPhase 1a. ballot-b的领导者发送1a信息给接受者\nPhase 1b. 一个接收者用一个包含它所投的最高ballot和与之相对应的v回复给领导者；或者回复自己还没有投票\nPhase 2a. 根据收到的来自quorum个接收者的1b信息，领导者可以选择一个安全的value v，并将它作为2a信息中的待投票值\nPhase 2b. 接收者基于来自领导者的2a信息，一个接收者通过发送2b信息来在ballot b为v投票\n在Phase 2a的行动中，领导者必须从quorum个1b信息中决定一个安全的值，它通过遵从算法的下列属性来达成这一目的。\nP3a. 如果quorum个接受者现在没有给一个比当前ballot小的值投票，那么所有值在当前ballot下都是安全的\nP3b. 如果在quorum个1b消息中已经有一些接受者投票了，那么选择小于ballot b中最大的ballot c, 在ballot c中投出的值v在ballot b是安全的。(根据P2，这样的值只有一个)\n我们仅仅指出要满足活性的性质，ballot-b的领导者要能够在Phase 2a阶段从quorum个接受者的ballot-b 1b信息中决定一个安全的值。（活锁就是两个proposer因为没有收到足够的ballot-b 1b信息而持续race ballot导致的,如果这里我们陈述有leader,那么就不存在活锁，如果我们能正确地选择safe value,即使会偶尔出现faulty leader,我们也可以预见在有限的轮数内能够完成quorum acceptor接受相同的值，从而reach quorum）\n3. Byzantizing An Algorithm 我们通过让N个接受者在有f个假装接受者的情况下模拟一个共识算法，来对其进行拜占庭化。同时不是接受者的进程也可能是拜占庭的，特别是一个拜占庭化的Paxos算法必须能够容忍恶意的领导者，然而一个无恶意行为的领导者是满足活性所必要的。\nemulation意味着执行一个操作，在refinement mapping下，该操作是emulated algorithm的操作。refinement mapping将emulating system (the implementation)的每个状态映射到the emulated one (the specification)的一个状态。\n我们提前假设哪一个进程可能是恶意的，因为拜占庭化的算法假设我们对于谁是real的接收者和谁是fake的接收者一无所知，所以这样的假设结果不会损失一般性。此外，由于恶意进程可以做任何事情，包括像非故障进程一样行事，我们可以通过假设正好有f个fake的接受者从一开始就是恶意的，来证明该算法可以容忍至少f个恶意接受者。\n我们将 byzacceptors 的集合定义为real和fake接受者集合的联合。我们将byzquorum 定义为一个保证包含 a quorum of real acceptors 的 byzacceptors集合。如果一个quorum由任何q个接受者组成，那么一个byzquorum由任何q+f个byzacceptors组成。为了保证liveness，我们需要假设所有real接受者集合（我们假设它们永远不会失败）能够形成一个byzquorum.（此处和之前一样）\n在拜占庭化的算法中，一个非故障进程必须确保其模拟中的每个动作都能够在原始算法下被执行。\nPaxos共识中的关键行动是领导者的第2a phase的行动，它根据属性P3a和P3b选择一个安全值\n领导者可以推导出P3a成立，如果它收到byzquorum个1b消息并且断定他们的发送者没有进行投票（因为byzquorum包含quorum的接收者）\nP3b可能会出现问题。在拜占庭化的算法中，我们无法决定一个1b消息是来自real还是fake的接受者。一个可以保证安全性的方式是要求被选择的拥有最高ballot number的值来自f+1个byzacceptors。但这样严苛的要求会使我们丧失活性，因为可能存在这样一种状态：因为有的real接受者还没有投票，所以我们收到的f+1个来自real接受者的1b消息并没有都投票给同一个值 ！（这个时候我们还是在N \u0026gt; 2f的情况下考虑问题，保证了安全性，但没有保证活性。换句话说，为了保证协议的活性，我们在收到一定数量的1b消息后必须做出抉择）\n一个解决这个问题办法是假设N \u0026gt; 3f。在这种情况下我们能在收到更多数量的1b消息后再做出抉择，并且同时还保证了活性,此时任何两个quorums有至少f+1个公共的接收者。这个时候因为增加了N的数量所以quorum也被增加为至少2f+1\nP3a和P3b将会被替换成。\nP3a‘ 如果f+1个ballot c小于b的接受者还没有投票，那么所有值在ballot b都是安全的。\nP3b’ 如果f+1个ballot c小于b的接受者已经投票，那么这个ballot c对应的值在ballot b是安全的。\nPhase 2a只有在收到了byzquorum个1b消息才能进行，如果P3a‘没有成立，那么我们就可以应用P3b’,然而这是不满足的因为这会导致我们需要多于4f个接受者。（因为为了满足活性，那么我们收到的2f+1个消息后就要做出决定，但是这2f+1个消息可能可以被分为三种类型：1.投票给上一个ballot的安全值。2.未投票。3.伪造的投票。因为在考虑安全性时我们没有任何同步假设，即消息可能丢失，所以我们存在这样一种状态：第三种消息在2f+1个1b消息中的比例等于第一种消息且未投票的接受者数量不满足P3a‘，这个时候我们难以做出抉择！（例子：在收到的2f+1个1b消息中有f个fake vote，f个real vote, 1个no vote）更简单地说，因为之前接受者不会撒谎，所以出现在1b消息中的值是唯一的，而此时接受者是拜占庭的，所以。所以为了能够表决出伪造的投票，我们需要增加quorum的数量，我们需要让quorum 中至少有f+1个1b消息投给相同的值(no vote/a value voted)以帮助proposer做出决定，此时 quorum至少为2f+1个来自real接受者的1b信息可以帮我们在正确的值中做出抉择（no vote/a value voted），再加上f个来自fake接受者的1b信息，所以此时 byzquorum至少为3f+1 个1b消息。同时为了满足活性，所以需要至少4f+1个接受者。（Lamport这部分直接一笔带过,所以这部分的例子和推导是我自己想的，不保真但是可以说服我自己！）这里用于shrinkN \u0026gt; 4f的解决办法是杜绝接受者撒谎，后面会解释！\n这里还有另外一个问题。为了能够使Phase 2a能够进行，leader也不能发送不同的2a消息。如果P3a’成立，一个恶意的节点可能发送两种不同的2a消息，这可能导致两种不同的值在两个之后的ballot中被选择。\n解决leader欺骗的方法是让leader和acceptors合作模仿Phase 2a的执行，使用一个新的Phase 2av行动。 领导者leader发送为一个特定的值v执行Phase 2a的请求给byzacceptors。一个接受者通过执行一个发送关于value v的2av消息给所有byzacceptors的Phase 2av行动来响应这个请求。一个byzacceptor执行Phase 2av, 只有当\n它能决定这样的一个2a消息在算法中能够被发出。\n在当前的ballot中，它还没有执行Phase 2b行动。\n一个接受者可以执行Phase 2b行动，如果它收到byzquorum个有同一个值的2av信息。由于任意两个byzquorums有至少一个公共的real acceptor, 所以没有两个real接受者会因为各自收byzquorum个两个不同的值，而执行不同的Phase 2b行动（为不同的值投票）。\n(这部分对应PBFT中阶段的关系是Pre-Prepare+Prepare: Phase 2av; Commit: Phase 2b)\n4. Algorithm PCon 这个章节介绍一个我们称之为PCon经典Paxos共识算法的变体。就像经典的Paxos，它假设N个接受者（N \u0026gt; 2f+1）\n在上面描述的经典Paxos算法中，一个ballot-b 2a消息有两个功能：\n（1）它断言这个值在ballot-b是安全的。\n（2）它指示接受者们在ballot-b为这个值投票。\n在算法Pcon中，我们引入1c消息来实现（1），同时我们运行leader发送多个1c消息去断言多个值是安全的。我们引入了Phase 1c和Phase 2a.\nPhase 1c. 使用来自quorum个接收者的1b消息，leader选择一组在ballot b安全的值，同时为每一个值发送一个1c消息。\nPhase 2a. leader为一些已经为它发送了1c消息的值发送一个2a消息。\nleader不需要一次性发送所有的1c消息；它能使用单个ballot执行Phase 1c行动多次。而对于如何在Phase 1c行动中选择一个安全值，ballot-b的leader从quorum个接受者处收到1b消息后，用如下情况进行选择。\nP3a. 如果quorum个接受者现在没有给一个比当前ballot小的值投票，那么所有值在当前ballot下都是安全的\nP3c. 如果一个值为v的ballot-c消息在Phase 1c被发出，对于c \u0026lt; b。1. quorum个接受者现在没有为任何大于c小于b的ballot投票。 2. 这quorum个接受者的任何一个在ballot-c进行了投票且都投票给了v，那么v在ballot-b就是安全的\nballot-b的leader应该将1c消息发送给谁？以及它如何知道在lower ballot被发出的1c消息是哪些，从而检查P3c是否成立？在PCon中，1c消息是逻辑构造的，而不需要实际发送。发送一个2a消息意味着必要的1c消息已经被发出，一个报告在ballot c投票的1b消息意味着一个ballot-c 1c消息必须被发出过。（也就是如果一个1b消息报告在某个ballot给某个值投了票，如果这个1b信息是安全的，那么曾经应该有一个与之这个值对应的1c信息在某个更小的ballot被发出过） 既然这个1c信息是我们逻辑构造的，那么我们为什么要在之前的算法中引入他呢？\n系统不可能基于一个固定的接受者集合长时间地运行。接受者可能被移除和添加——一个叫做reconfiguration的程序。在经典的Paxos中，reconfiguration发生在共识实例间，单实例能够有效地被单个固定的接受者集合执行。现在已经有算法提出在单个共识实例地执行间进行reconfiguration，使用不同的ballot和可能不同的接受者集合：Vertical Paxos和未发表的Cheap Paxos（2023年了不知道发表了没有= =！）1c消息的作用是消除对于lower-numbered ballots接受者的依赖，它们可能已经被reconfigured out了(比如一个接受者接受了，但他被移除出了系统)。 当一个新的活跃leader开始ballot b时，情况P3a适用于ballot b第二阶段阶段尚未开始的无限多个实例。leader的1c消息可以通知未来的leader这个事实，因此，他们不必了解在编号小于b的ballot中的投票情况。（有点没懂，翻译也看不明白！但是按照我的理解就是未来的leader可以靠1c知道任何在比b小的ballot的投票情况？好像有道理，未来的leader是现在的acceptor,那么因为现在的acceptor收到了1c信息，那么未来如果它成为leader，它就能够根据之前收到的1c信来检查P3c的情况是否成立）\n根据定义，如果两个不同的值在ballot b是安全的，那么所有的值在ballot b都是安全的。 除了发送消息说一个单一的值是安全的，或者发送消息说所有的值都是安全的，领导者没有理由做任何其他事情。\n5. Algorithm BPCon 我们现在派生出算法BPCon通过拜占庭化N-acceptor算法PCon以及添加f个fake接受者。我们先考虑一个leader进程的行动。leader在算法BPCon中没有明确的2a消息或者Phase 2a行动。取而代之的是，接受者合作模仿2a消息的发送。ballot-b的领导者要求对已经发送过1c消息的值v进行2a阶段的操作。在收到第一个这样的请求后，一个接受者执行一个Phase 2av行动， 为value v发送一个ballot-b 2av消息。前提是它已经收到一个关于这个值的合法的ballot-b 1c\n因为leader的请求只对liveness是必要的，我们不刻意地去建模它。取而代之，我们允许一个接受者去执行一个ballot b的Phase 2av行动当且仅当它已经收到了必要的1C行动，并且还没有发送一个 ballot-b的2av消息。\n因为算法必须容忍恶意的领导者，我们让ballot-b的领导者能够发送任意它像发送的1a和1c消息（牢记我们不能发送一个看似是其他人发送的消息）。ballot-b 1a消息在PCon中只有一种可能性，同时被允许在Phase 1a行动的任何时间发送。于是在BPCon的Phase 1a行动中与PCon的Phase 1a一致。BPCon的phase 1c行动允许ballot-b的领导者在任何时候去发送任何ballot-b的1c信息。\n接受者将会忽略非法的1c消息。为了保证活性，一个无故障的领导者必须发送一个real接受者能够响应的消息。我们必须确定接受者如何知道一个1c 信息是合法的。\n在PCon中，通过上述P3a或P3c启用投票-B 1c消息的发送，这需要从一个法定人数中收到一组1b消息并可能收到一个1c信息。在BPCon中，我们将额外信息放入1b消息中使能够进行1c消息已经被发送的推导。一个接受者将所有它发送过的2av消息作为集合装进1b消息中——对每一个值，它只将它为这个值发送的最高ballot的2av消息放入其中。这些被发送的2av消息中的每一个都对应一个合法的1c消息。 如同我们在第三节中关于拜占庭化的讨论,这意味着给定一组来自byzquorum关于ballot b的1b消息S，以下两个条件分别对应之前的P3a和P3c：\nBP3a. 每个在S中的消息都断言它的发送者还没有投票。\nBP3c. 对一些c \u0026lt; b和一些值 v, (a)每个在S中的消息都断言 (i)它的发送者没有在任何大于c的ballot投票以及 (ii) 如果它在ballot-c的投票是v， 且(b)有f+1个来自byzacceptors的1b消息表明它们在ballot-c发送了关于value v的2av消息\n稍微思考一下就会发现我们可以弱化BP3c关于条件(b)断言：\n(b\u0026rsquo;) 如果存在f+1个来自byzacceptors的1b消息表明他们在一个大于或等于c的ballot发送了关于value v的2av消息\n去决定是否一个1c消息是合法的，每个接受者维护一个他们知道的已经发送了的1b消息的集合。 我们的抽象算法假设一个行动nondeterministically将实际发送的1b消息的子集添加进这个集合。当然，一些1b消息可能来自fake接受者。活性要求领导者确保接受者最终知道允许领导者发送 1c 消息的 1b 消息已发送\n如前面讨论的，当它从quorum个接受者收到相同的2av消息，一个接受者才能执行Phase2b行动。一个PCon的2a消息被一组被quorum发送的相同的2av消息模拟，同时Phase2a被这组相同的2av消息中最后被发送的那条信息所模仿（代表）。\n6. 关于被发送消息的活性和学习 PCon的活性要求一个无故障的领导者执行一个ballot b时没有另一个leader开始一个更高的ballot,同时leader和无故障的接受者能互相通信。BPCon的活性要求和PCon也是一样的。然而。这很难去确保一个拜占庭的领导者不执行一个更高的ballot。解决这个问题需要一些基于实时假设的工程解决方案。\n假设这些要求，BPCon的活性要求满足以下两个条件：\nBL1. 领导者能找到满足BP3a或者BP3c的1b消息。\nBL2. 全部真的接受者将知道那些已经被发送的消息。\n这两个条件意味着领导者将发送一个合法的1c消息，byzquorum的real接受者将收到1c消息以及发送2av消息，所有在byzquorum的接受者将收到哪些2av消息以及发送2b消息。学习者根据收到的这些2b消息将会学习到被选择的值。\n为了证明BL1成立，ballot-b的领导者最终会从BQ的接受者们那里收到1b的信息。让S记作这些1b消息的集合。我们现在证明BP3a或者BP3c成立。\n只要假设BP3a是假的，并证明BP3c就可以了。\n令 c 为 BQ 中的接受者投票的最大ballot，令 a 为这样的接受者，并令 v 为其投票的值。\n证明：由1的假设可以得出存在这样一个 c。\n接受者a收到来自byzquorum的在ballot-c的关于值v的2av消息。\n证明：通过2以及Phase2b行动的启动条件。\n没有其他接受者在ballot c给其他不是v的值投票。\n证明：通过2可以证明，因为任何两个byzquorums由一个公共的接受者，以及一个接受者最多发送一次ballot-c的2av消息。\n至少f+1个接受者发送关于值v的ballot-c 2av消息。\n证明：通过3证明，因为一byzquorum包含至少f+1个接受者。\nBP3c的条件(b‘)成立。\n证明：通过5，因为一个发送一个关于value v的ballot-c 2av消息的接受者意味着，对于b \u0026gt; c，它的ballot-b 1b消息将会报告它在某些大于等于c的ballot发送过一个关于value v的2av消息。\nBP3c的条件(a)成立。\n证明：通过2(没有在BQ中的接受者在大于ballot-c的ballot投票)，以及4\nQED。\n证明：通过1，6和7。\n这表明 BL1 最终成立。 为了证明活性，我们需要证明 BL2 成立。 为了确保它成立，领导者必须有办法确保所有真正的接受者最终都知道发送了 1b 消息。 如果 1b 消息是由真正的接受者发送的，那么该接受者可以将其 1b 消息广播给所有的byzacceptors以及领导者 我们现在提出两种方法来确保接受者知道发送了 1b 消息，即使它是由假接受者发送的。\n6.1 发送证明 最简单的方法是领导者在其 1c 消息中包含一个证明，证明所有必要的 1b 消息都已发送。 最简单的方法是使用完整的数字签名并让 byzacceptors 签署他们的 1b 消息。领导者可以在其 1c 消息中包含必要的正确签名的 1b 消息。\n还可以使用MACs。一个MAC是一个签名Mp-\u0026gt;q，一个进程p能够附带在一个消息m上，向进程q证明p发送了m。MAC Mp-\u0026gt;q不能向除了q以外的其他进程证明任何事。\n假设一个消息m断言一个确定的事实，一个进程q收到这个消息以及从f+1个不同的进程p的MAC Mp-\u0026gt;q。因为最多有f个拜占庭进程，他们中的至少一个进程的断言是真的。然而，q不能向其他任何进程证明这个事实是真实的。然而，假设它从2f+1个进程收到一个MACs的向量向量\u0026lt; Mp-\u0026gt;r1, \u0026hellip;., Mp-\u0026gt;rk \u0026gt;以及这个消息。向量中的至少f+1由无故障进程p发送，所以他们有正确的MACs以及能够说服对应的ri进程有一个无故障的进程发送了M。因此，q能够发送消息m以及这样的MACs的2f+1个项的向量给每个进程ri作为m的断言的证明。\n6.2 中继1b消息 我们现在描述另一个方式能确保好的接受者知道1b消息被发送了（接受者最终知道允许领导者发送 1c 消息的 1b 消息已发送）。我们让byzacceptors广播他们的1b消息给所有的byzacceptors（包括领导），同时让他们中继这个1b消息给他们的领导者以及其他byzacceptors。根据收到来自2f+1个byzacceptors的1b消息，领导者知道至少f + 1个真的接受者发送或中继给了所有byzacceptors。假设对活性的要求，这意味着所有的接受者最终都会从 f +1 个不同的的byzacceptors那里收到 1b 消息的副本（因为f+1个真的接受者会根据协议广播，并中继别人的1b消息），从中它推断出消息确实被发送了。（由其他人转发代表真的广播了）\n这是Castro和Liskov使用的基本方法。 然而，在他们的算法中，byzacceptors 仅将广播的 1b 消息（他们称为 view-change-acks）转发给领导者（他们称为primary）。 领导者在其 1c 消息中包含（摘要）1b 消息，并且接受者要求其他 byzacceptors 中继 1c 消息中它尚未收到的任何 1b 消息。\n7. Castro-Liskov算法 Castro-Liskov算法，就像Paxos，运行一个状态机通过执行一个有无限实列的共识算法。它包含对于处理实例的顺序的工程优化，特别是对于旧实例的垃圾收集，以及对于修复进程的状态迁移。我们认为，这些优化可以通过对经典Paxos的相应优化进行拜占庭化来获得，但是他们与共识无关。一些其他优化，比如不发送完整信息而是发送消息的摘要，是一些我们为了简单起见而忽视的细节。\n当我们忽视这些细节，只关心Castro-Liskov的共识算法本身，我们剩下的是一个完善BPCon的算法。在Castro-Liskov算法中，byzacceptors被叫做replicas。 ballot-b的领导者叫做primary，其他byzacceptors被叫做backups。replicas也被称作学习者。 我们通过描述 BPCon 的消息是如何实现的来解释 Castro-Liskov 共识算法是如何改进 BPCon 的。\n1a 没有明确的1a消息；当复制体决定开始view change时，其发送是由复制体合作模仿的。\n1b view-change消息。\n1c 在view change期间，new-view消息对所有共识实例来说就像1c信息一样。 对于一个primary指示replicas去选择一个特定值的实例，它是具有该值的 1c 消息。 对于所有其他实例，它是所有值的一组 1c 消息。 （条件 BP3a 在那些其他实例中成立。）接受者同时为所有实例检查这些 1c 消息的有效性。\n2av 这是一个backup的prepare消息。primary的pre-prepare消息serves as 2av消息以及请求一个Phase 2a行动\n2b 这是Commit phase\n如同在6.2节中解释的一样，Castro-Liskov算法的view-change-ack被用作中继1b消息给领导。它的reply消息被replicas发送，作为learners去通知client被选择的值。\n我们在第 3 节中解释了拜占庭经典 Paxos 的困难。 我们无法从经典的 Paxos 中获得 Castro-Liskov 算法并不是拜占庭化的缺陷； 这是因为该算法没有对经典的 Paxos 进行细化——至少，在任何简单的细化映射下都没有。 在 Castro-Liskov 共识算法中，领导者可能需要预先准备一个值 v，即使在之前的视图中没有副本提交过 v。 这在经典的 Paxos 中是不可能发生的。\n","permalink":"/posts/read/byzantizingpaxos/","summary":"之前对于Byzantine Paxos的理解完全建立在Youtube上Mu Shuai老师的讲解视频上，现在决定好好读一遍Lamport老爷爷的","title":"ByzantizingPaxos"},{"content":"有许可区块链是一种分布式账本技术（DLT），它牺牲了一定程度的去中心化和匿名性，以更好地适应商业需求，以及实现更高的网络速度和效率。\n在这篇文章中，我们将介绍无许可区块链和有许可区块链，同时探讨这两种DLT解决方案之间的核心差异。\n什么是区块链网络？ 在我们深入探讨我们的主题之前，让我们首先重温一下区块链技术的基本知识。\n随着比特币的推出，区块链是一个数字账本，它被复制并分布在网络中所有参与者的设备上。\n因此，区块链的每一个变化都会实时透明地记录在所有参与者的账本上。这意味着，网络中的每个人都会看到一个具有相同记录的分布式账本，允许用户审计和追溯交易。\n在传统网络中具有正确访问级别的个别参与者可以对服务器的数据进行修改，但区块链网络中验证者必须通过工作证明（PoW）或取证（PoS）等机制达成共识，才能更新区块链。\n由于这个原因，一旦某件事被记录在分布式账本上，单个用户就不能修改、删除或篡改数据，这使得区块链在本质上是不可改变的。\n此外，区块链通过庞大的计算机网络来维护生态系统，消除了单点故障。\n由于分散在世界各地的数千台（甚至数百万台）设备向链上添加新的区块并验证交易，区块链对网络攻击更加安全，因为黑客必须接管网络的大部分（而不是单一的服务器）才能获得控制权。\n所有的交易都通过公钥加密技术进行加密，因此区块链网络可以没有第三方或中间人的情况下连续运行。\n什么是无许可区块链？ 例子: Bitcoin, Ethereum, Litecoin\n无许可区块链是加密货币社区用户最熟悉的DLT技术类型。\n这不应该是一个惊喜。\n比特币、以太坊和大多数加密货币的底层区块链网络都使用这种形式的分布式账本。\n在一个无许可的区块链网络中，任何人都可以参与并成为验证者。\n例如，如果你有一个兼容的设备和一个工作的互联网连接，你可以自由地创建一个比特币钱包，甚至通过成为一个矿工来维护这个网络。\n无许可的区块链网络完全缺乏访问控制。\n因此，普通用户和验证者都不需要验证他们的身份或提交了解你的客户（KYC）文件来加入。相反，他们可以在保持匿名或假名的情况下参与网络。\n无许可区块链的好处是什么？ 去中心化: 由于对验证者没有访问控制或限制，无许可区块链网络是真正的去中心化。每个参与者都是平等的，没有人可以对其他人行使更大的权力。\n加强安全保障： 对验证者没有限制，激励了更多的参与者来维护区块链。出于这个原因，大多数无许可账本都有大量的验证者，增强了网络的安全性。\n隐私： 由于参与者不需要提供任何个人资料或文件来加入，无许可区块链的特点是增加了隐私，允许用户在与网络中的解决方案互动时保持匿名或假名。\n社区自治： 大多数无许可区块链不是由公司、政府或其他中心化实体管理，而是由项目的社区管理。\nCensorship resistance： 由于高度的去中心化和大量的验证者，permissionless blockchains are effectively resistant to censorship.\n无许可区块链的缺点是什么？ 有限的速度和可扩展性：由于它们具有大量的验证者，他们都需要达成共识来处理转账和向链上添加新的区块，因此无许可区块链经常面临着可扩展性和交易吞吐量有限的问题。\n链条分裂的风险: 在无许可的区块链网络中，社区必须紧密合作以维护生态系统。然而，矿工之间的激烈辩论和分歧会分裂社区，也会在硬分叉（与之前版本不兼容的重大升级）期间分裂区块链。\n能源效率问题: 比特币、以太坊和许多其他主要区块链为达成共识而部署的工作证明（PoW）算法是高度能源密集型的，因为矿工需要操作物理设备来解决复杂的数学难题。因此，BTC挖矿消耗的能源比瑞典一年的能源还要多。也就是说，许多无许可区块链正在将其共识机制升级为更节能的算法（例如，Proof-of-Stake），以解决此类问题。\n恶意活动的风险: 虽然大多数无许可区块链可以有效地防止黑客攻击，但它们不能防止网络犯罪分子进入网络并针对生态系统中的解决方案。\n什么是许可的区块链？ 例子： ConsenSys Quorum, Hyperledger Fabric, R3 Corda\n与无许可区块链相反，有许可的区块链是一种DLT解决方案，对验证者进行访问控制。\n这可能意味着设置一个要求，要求网络中的所有验证者提供KYC文件。\n另外，在大多数情况下，管理许可账本的组织或社区会选择用户来验证生态系统中的区块。\n此外，许可区块链限制了网络中验证者的最大数量，以提高效率，并实现更高的吞吐量和可扩展性。\n虽然有些许可区块链对标准用户也有访问控制，但其他区块链只限制谁可以成为验证者（后面会详细介绍）。\n与迎合大众的无权限区块链不同，有权限的区块链更适合企业使用，因为它们可以更容易地定制，以适应个别业务需求。\n许可区块链的好处是什么？ 增强的可扩展性和速度： 许可区块链的特点是只有少量的验证者。因此，它们可以比无权限的同类产品更快地达成共识，同时实现高可扩展性和速度。\n可定制性： 通过对验证者的访问控制，管理许可区块链的企业可以设置自己的规则，并定制网络以最适合他们的需求。\n遵守规定: 许可账本为企业提供了对网络基础设施的更多控制，这使他们能够更有效地履行合规要求。\n有限的恶意存在： 通过对验证者的有效访问控制，许可的区块链可以有效地消除（或至少限制）生态系统中恶意方的存在。\n成本有效： 少量的验证器提高了可扩展性和吞吐量，并降低了网络运营的成本。\n许可区块链的缺点是什么？ 增强的中心化： 由管理链的组织或社区选择，只有数量有限的验证者可以参与到许可网络中。虽然去中心化的程度因网络而异，但有许可的区块链比无许可的区块链更中心化。\n低透明度： 有许可的区块链的透明度是基于组织本身进行怎样的管理。虽然一些企业可能决定保持与无许可区块链相同的透明度，但一些企业不愿意与参与者分享其流程和程序的信息。\n隐私性下降： 由于验证者\u0026ndash;在某些情况下也包括标准用户\u0026ndash;必须通过KYC，所以有许可的区块链的特点是隐私有限，使得大多数参与者几乎不可能以假名方式使用网络。\nNo resistance against censorship： 由于网络是由一个必须遵守法规的组织管理的，因此许可区块链在某些司法管辖区可能会受到审查。\n潜在的安全问题： 通过适当的访问控制，许可的区块链可以在其网络中保持高水平的安全。然而，由于验证者的数量较少，恶意的一方比无许可的账本更容易渗透到有许可的区块链中。\nPermissioned vs. Permissionless vs. Public vs. Private Blockchains Public和permissionless，以及private和permissioned，是加密货币领域的区块链解决方案经常互换使用的概念。\n然而，public和无permissionless以及private和permissioned的区块链之间存在着重大的区别。\npermissioned和permissionless是用来描述DLT网络是否对验证者有访问控制的短语whether has access controls in place for validators。简单地说，这些链的类型有不同的access规则。\n任何人都可以成为permissionless中的验证者，但用户必须通过KYC检查和通过投票程序来验证permissioned网络中的区块。\n然而，上述两种表达方式并不包括区块链是否开放给标准用户参与。\n当一个区块链是public，任何人都可以访问网络并审计分布式账本上记录的数据。从本质上讲，所有permissionless链都是公开的。\n另一方面，private链只允许选定的用户进入网络。在大多数情况下，只有那些已经通过KYC检查并得到管理员批准的人可以加入。Private DLT解决方案限制了用户的access权限。没有权限的人既不能查看链上的数据，也不能成为网络中的验证者。出于这个原因，所有的私有区块链也是有权限的。\n另一方面，市场上有public permissioned 区块链，允许任何人查看账本上的记录并与网络内的解决方案互动，但有措施限制谁可以验证区块。\n[1] Permissioned vs. Permissionless Blockchains Explained\n","permalink":"/posts/tech/permissionedorless/","summary":"有许可区块链是一种分布式账本技术（DLT），它牺牲了一定程度的去中心化和匿名性，以更好地适应商业需求，以及实现更高的网络速度和效率。 在这篇文","title":"[翻译]Permissioned vs. Permissionless Blockchains Explained"},{"content":"Problem In general blockchain, every single node is required to replicate, validate, store and maintain the states of all users in entire network.\nSolution This paper present a idea to divide the blockchain into different asynchronous consensus zones (multi-instanitiation of independent blockchain systems). Partitioning workloads of the entire network, distribute to zones. Parallelize blovk creation and transaction handling since we have multi-independent blockchain. To achieve linear scalability as the entire network is divided into more zones.\nBackground The system presented by this paper use Account/Balance transaction models and PoW. This paper uses the account/balance model due to its simplicity since a transaction with an arbitrary amount can be performed with one sending account and one receiving account. Another important benefit offered by the account/ballance model is allowing transactions to carry incremental updates of states, as oppose to the UTXO transactions that can only carry full states.\nSystem Design\rHandling a payment that involves two users from different zones example:\nThe withdraw oper\u0002ation ρ that only involves the state in zone A is handledby a miner in zone A. If the account balance satisfiesthe cost of this withdraw operation, the corresponding block t + 1 carrying the transaction (initiative transac\u0002tion) will be created by the miner and only be appendedto the chain of zone A. After that, a relay transactioncarrying the deposit operation φ is composed in zone Aand forwarded to zone B. The deposit operation φ thatonly involves the state in zone B can always be executed,regardless of the balance of the target account in zone B.Once the relay transaction is picked up by another minerin zone B, operation φ will be executed, concluding thecomplete of the payment transaction.\nPartitioning and Naming The account of user is represented by its address(a fix-sized hash value of its public key). Uniformly partitioning the space of user address into 2 power to k zones: a zone is identified by its sharding scale k and zone index s.\nThe zone index of an initiative transaction is determined by the payer\u0026rsquo;s address, and the zone index of a relay transaction is determinated by the payee\u0026rsquo;s address.\nIn the system of paper, full nodes join swarms to broadcast new transactions and receive blocks from other full nodes. A swarm is a group of nodes that participate in the replication of the same data set. For example, in Bitcoin or Ethereum, there is only one swarm and every full node replicates the same dataset, including all blocks and transactions. In the system of paper, there is a global swarm which joined by all full nodes for replicating the minimum common information of all zones. the most communication occurs in zone-specific swarm with full nodes belonging to specific zones only. In each swarm, the participating full nodes are sparsely connected, and use the gossip protocol to broadcast message.\nIsolated Intra-Zone Workload A full node, or a miner, will have a persistent identifier that is initialized randomly. With address space partitioning, a blockchain is established within each zone independently. Only care about their own zone! They should ignore any blocks or transactions received that do not belong to their zone(although those are unlikely to be received).\nMinimized Cross-Zone Overhead In a blockchain system, most communication is for replicating unconfirmed transactions and for broadcasting new blocks carring confirmed ones. But since now we have isolated zones, so the most communication is performed only among nodes within the zone. Each node maintain a DHT to help them find the specific zone for their peers. After getting the zone index s of an unconfirmed transaction or a forwarding block, system selects out nodes having the same zone index as s based on the lcoal DHT routing table, and it sends the transaction and block to these nodes following the gossip protocol. This way help to minimized data for chain forming excluding actual confirmed transactions are replicated across all zones (what is the actual confirmed transactions?)\nContribustion\nContribution Efficient Cross-Zone Atomicity Chaining-block a pointer to the precursor block\na PoW nonce\na Merkle tree root of the list of confirmed transactions\na Merkle tree root of the list of all relay transactions originated from initiative transactions in this block, which is used for the validation of relay transactions in other zones.\nDual-stage transaction handling mechanism By deriving and forwarding a relay transaction that carries the deposit operation to its destination zone.\nTransaction Validation and Forwarding at Zone A\nA miner pick up a unconfirmed transaction when they are constructing a new block.\nThe initiative transaction is validated if the balance of a is less than the transfer amount, this transactin wil be marked as invalid, and be concluded and embedded in the block.\nOtherwise, a chaining-block and a transaction-block are constructed. Transaction-block has a list of validated transactions including the one from a to b.\nThe miner work on the PoW puzzle specific to the list of all confirmed transactions.\nAfter the PoW puzzle is solved, the chaining-block is broadcast in the global swarm and the transaction-block is broadcast in a\u0026rsquo;s zone-specific swarm.\nWhen the other nodes wihtin this zone received the transaction-block, the intra-zone transactions are executed and concluded. The withdraw operation in all cross-zone transactions are then executed(on the other zones).\nEach cross-zone transaction derives an outbound relay transaction, which will be sent to the destination zone.\nRelay Transaction Handling at Zone B\nAn inbound relay transaction is picked up by a miner in payee b\u0026rsquo;s zone when constructing a new block.\nThe miner verifies the inbound relay transaction against its originate block. Skip this if invalid.\nThe miner constructed a new chaining-block and a new transaction-block including the inbound relay transaction.\nAs same as before the chaining-block will be broadcast in global swarm and the transaction-block will be broadcast in b\u0026rsquo;s zone after the PoW puzzle is solved.\nThe deposit operation is executed, concluding the transaction.\nVerification Let\u0026rsquo;s skip this part and regard it as a black box to use!!!\nEventual Atomicity A payment transaction involving withdraw and deposit operations, should be atomic to ensure corrrectness of the global ledger!!!\nRSCoin and OmniLedger use two-phase commit mechanism to ensure the atomicity, with the known lock/unlock overhead.\nIn this system, for a cross-zone trnsaction, allow the withdraw operation to execute first, then the the corresponding deposit operation to be settlled later. They call such an atomicity, eventual atomicity.\nTheir design ensures is that relay transactions will not be discriminated by sufficiently incentivizing with a fee split.\nfee split: incentivize both miners working on initial step and relayed step of transaction handling\nA rational miner prioritizes unconfirmed transactions based on the transaction fee. This paper introduce fee splitting for cross-zone transactions. The author recommend cross-zone transaction issuer set double or even triple the amount of transaction fees to make sure the relayed transactions can be prioritized with transaction fee after fee split.\nWe introduce fee splitting for cross-zone transactions,which incentivize both miners working on initial step andrelayed step of transaction handling so that relayed trans\u0002actions will be equally prioritized with transaction feesat similar levels 最后一句陈述的意思是处于similar level(worklaod 类似)的initial step of transactions和relayed step of transactions能够平等地根据transaction fee来区分优先级。\nIn the existing blockchain system, a payment transac\u0002tion will be visible to its payee once it is packed in ablock on the chain (first confirm). It will be secured aftern − 1 successive blocks appended (n-th confirm, n = 6in Bitcoin and 12 in Ethereum). In contrast, a cross\u0002zone payment transaction in our system will be visible to the payee, once its relay transaction is forwarded to thepayee’s zone, and its originate block becomes available.With the eventual atomicity, the transaction is consideredas eventually secured, once its initiative transaction gets n-confirmed, and the relay transaction gets a first confirm. (这一段是关于可见性的)\nFork Resolution Let\u0026rsquo;s skip this part!!!\nMining Power Diluted with Multiple Zones Skip this part now!\n[1] nsdi19-wang-jiaping.pdf (usenix.org)\n[2] Monoxide: Scale out Blockchains with Asynchronous Consensus Zones | USENIX\n","permalink":"/posts/read/monoxide/","summary":"Problem In general blockchain, every single node is required to replicate, validate, store and maintain the states of all users in entire network. Solution This paper present a idea to divide the blockchain into different asynchronous consensus zones (multi-instanitiation of independent blockchain systems). Partitioning workloads of the entire network, distribute to zones. Parallelize blovk creation and transaction handling since we have multi-independent blockchain. To achieve linear scalability as the entire","title":"Monoxide: Scale out Blockchains with Asynchronous Consensus Zones"},{"content":"Abstract \u0026ldquo;Scaling blockchain systems under general workloads remains an open question\u0026rdquo;.\nThe challenges of scaling are different between databasebases and blockchain since they have different failure models.\nThe major contribution of this paper:\nEnhance the performance of Byzantine consensus protocols -\u0026gt; inprove the individual shard\u0026rsquo;s throughput.\nDesign an efficient shard formation protocol -\u0026gt; leverage a trsted random beacon to securely assign nodes into shards.\nDesign a general distributed transaction protocol -\u0026gt; ensure safety and liveness even when transaction coordinators are malicious.\nIntroduction The tradeoff between strong security and scalability (the consensus protocol blockchain systems have to rely on is scalable poorly)\non hardware aspect -\u0026gt; \u0026ldquo;trusted hardware has not been demonstrated on data-intensive blockchain workloads\u0026rdquo;\nsharding -\u0026gt; divide the blockchain network into small committees to reduce the overhead of consensus protocols\nThis paper extend sharding to permissioned blockchian systems\nBFT consensus protocols in trusted execution environment(TEE) Leveraing trusted execution environment to eliminate equivocation(provide different values to its neighbors) in the Byzantine failure model -\u0026gt; achieve higher fault tolerance with the same number of nodes [(n-1)/3 - \u0026gt; (n-1)/2].\nNo necessary to understand too many details\nEfficient shard formation protocol Leverage the TEE to design an efficient and secure shard formation protocol -\u0026gt; implement a trusted randomness beacon inside the TEE to generate unbiased random values in a distributed setting\nThe nodes derive their committee assignment by computing a random permutation pi [1 : N] seeded by rnd. pi is then divided into approximately equally-sized chunks, each of which represents the members in one committee. To exploit TEEs to efficiently obtain rnd. Each new epoch correspondings to a new node-to-committee assignment, nodes invoke the enclave with an epoch number e to generate two random values q and rnd. If and only if q = 0. \u0026lt;e,rnd\u0026gt; is broadcasted to the network. After a time theta, nodes lock in the loweast rnd they receive for current epoch e, then use it to compute the committee assignment.\nNo necessary to understand too many details (Committee size, Shard Reconfiguration)\nUTXO transactions Consists of a list of inputs, and a list of outputs. All the inputs must be the outputs of previous transactions that are unspent. The outputs of the transaction are new, unspent coins. (Given a transaction, its inputs are unspent and the sum of the outputs is not greater than that of the inputs, if two transactions consume the same unspent coins, only one is accepted)\nDistributed transactions!!! RapidChain exploites UTXO model to achieve atomicity but can not achieve isolation. And it also fails to work for non-UTXO distributed transactions, because it violates both atomocity and isolation.\nOmniLedger achieves safety for the UTXO model but remain the liveness issue.\nThe design of this paper:\nDesign a distributed transaction protocol that achieves safety for general blockchain transactions (non-UTXO) and liveness against malicious coorinators\nSafety: two-phase commit (2PC) and two-phase locking (2PL)\nLiveness: To guard against a malicious coordinator -\u0026gt; BFT reference committee serve as a coordinator\nThe BFT reference committee is also a shard which formulated by a certain number of nodes.\nThe client initiates a transaction tx by sending BeginTX request to the reference committee.\nPrepare: Once R has executed the BeginTx request, in other words, the quorum of nodes in the R have reached the consensus on this request. it enters \u0026ldquo;Started\u0026rdquo; state. Nodes in R then send PrepareTx requests to the transaction committees(transaction shard). The tx-committee will wait for a quorum of matching PrepareTx to ensure that BeginTx has been executed in R. The each tx-committee executes the PrepareTx. If consensus is reached that tx can be committed, which requires that tx can obtain all of its locks I am really comfused about this statement???), the nodes within the committee send out PrepareOK messages.\nPre-Commit: When entering “Started” state, R initializes a counter c with the number of tx-committees involved in tx:\nreceiving the quorum of matching responses from a tx-committee it will maintain the same state or enter a new state depend on the state machine input (PrepareOK or PrepareNotOK). (I am really comfused about how to regard a committee as a state machine!!! How keep the consistancy between nodes? Which node in the committee to deciede there is a quorum of matching response?)\nCommit: Once R has entered \u0026ldquo;Committed\u0026rdquo; state, the nodes in R send out CommitTx or AbortTx message to tx-committees. As same as before, the latter wait for a quorum of matching messages from R before executing the corresponding commit or abort operation.\n2PC and 2PL 2PC (used for distributed transactions): Two-phase commit is an algorithm for achieving atomic transaction commit across multiple nodes \u0026ndash; to ensure that either all nodes commit or all nodes abort.\n2PL (used for consistency and isolation in stand-alone transactions): provides serializable isolation\nGrowing: request locks\nShrinking: free locks\ndatabases often use an enhanced version of S(trong)S(trict)2PL, which is a little different compared to 2PL: the shrinking phase, which can only release the lock after the transaction is over, completely eliminates the uncommitted data of the transaction from being read.\nHow to handle dead-lock?\nDeadlock detection: database system draw the wait-for graph, dead-lock happens if there is a ring.\nDeadlock prevention: as requesting a lock that is already held, the database system kills one of the transactions to prevent deadlocks (generally the longer the transaction lasts, the higher the priority of the reservation). This prevention method does not require a waits-for graph, but increases the rate at which transactions are killed.\nReference [1] Towards Scaling Blockchain Systems via Sharding (arxiv.org)\n[2] 区块链相关论文研读7：通过分片（Sharding）扩展区块链 - 知乎 (zhihu.com)\n[3] Introduction to two-phase commit, Don\u0026rsquo;t confuse 2PC and 2PL (ebrary.net)\n[4] 一篇讲透如何理解数据库并发控制（纯干货） - 知乎 (zhihu.com)\n","permalink":"/posts/read/sharding1/","summary":"Abstract \u0026ldquo;Scaling blockchain systems under general workloads remains an open question\u0026rdquo;. The challenges of scaling are different between databasebases and blockchain since they have different failure models. The major contribution of this paper: Enhance the performance of Byzantine consensus protocols -\u0026gt; inprove the individual shard\u0026rsquo;s throughput. Design an efficient shard formation protocol -\u0026gt; leverage a trsted random beacon to securely assign nodes into shards. Design a general distributed transaction protocol","title":"Towards Scaling Blockchain Systems via Sharding"}]