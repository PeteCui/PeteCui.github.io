[{"content":"之前对于Byzantine Paxos的理解完全建立在Youtube上Mu Shuai老师的讲解视频上，现在决定好好读一遍Lamport老爷爷的原论文并记一下笔记！\nAbstract 我们通过拜占庭化一个普通的Paxos算法推导出一个3f+1进程的拜占庭Paxos共识算法。其中2f+1个nonfaulty进程模仿常规的Paxos算法，同时有f个恶意的进程。\n1. Introduction Paxos算法已经成为一个标准工具去实现一个容错的分布式系统。它使用2f+1个进程去容忍可能出现的f个良性故障。Castro和Liskov开发了一个3f+1进程的算法（PBFT）去容忍拜占庭节点。他们的算法看起来是一个拜占庭版本的Paxos,之后其他一些看起来是拜占庭版本的Paxos也相继出现。\n我们使用一个叫做Byzantizing的更直接的方式将一个分布式的非拜占庭算法推导得到一个拜占庭Paxos算法，Byzantizing 将一个能够容忍最多f个良性故障 N 进程算法转换为一个能够容忍 f 个拜占庭进程的 N+f 进程算法。在被拜占庭化后的算法中，N 个良好的进程模仿原始算法的执行。\n原始算法和拜占庭算法的心脏部分是共识算法。我们拜占庭化一个经典Paxos共识算法的变体，我们称它为PCon。同时将PBFT的抽象概括称为BPCon。\n2. Consensus and Classic Paxos 我们假设通常的异步进程分布式计算模型通过消息传递进行通信。良性的失败指消息的丢失和进程停止。一个拜占庭进程可能发送任何信息，但是我们假设接收者可以确定信息的发送者，这可以通过点对点通信实现或者message authenticators(MACs)\n2.1 Consensus 在一个完备的共识规范中，提议者发起提议，一组接收者一起选择提议值中的一个值，而学习者进程了解什么提议值（如果有的话）已经被选择。共识算法必须容忍一定数量 f 的接受者失败，以及任何提议者或学习者的失败。\n简单起见，我们不考虑提议者和学习者，只考虑接受者。我们关于什么值被选择的定义使如何实现“learning”变得清晰。在Byzantine条件下实现提议者不是容易的，因为我们要防止拜占庭节点伪装成无故障的提议者，但是Castro和Liskov已经解释了如何实现它通过使用数字签名和MACs。通过这种简化，共识的规范由一个平凡的算法组成，其中接受者最多可以选择一个值，但一旦选择了一个值，就必须永远保持选择状态。\n众所周知，容错共识算法不能在纯异步系统中实现。我们要求安全性质成立即使我们没有任何同步假设，而活性属性则在我们有一些同步假设的情况下在无故障进程上成立。\n2.2 Paxos Consensus 简单介绍了一下Paxos\nN：接收者的数量，N必然需要大于f\nquorum: 任何 N-f 个接收者。\n为了实现安全性我们需要任何两个quorum有一个非空的交集，那么 N \u0026gt; 2f ，比如N = 2f+1 ，那么quorum就是 f+1，在N中任意取两组数量为f+1的接收者，两组中一定有至少一个共同的正确进程。另一个关于quorum的性质是我们需要至少有一组quorum完全由无故障的进程组成，这是为了满足活性（理解很简单，因为如果没有这样的quorum存在，那么拜占庭节点可以一直通过无响应来永久的地阻止共识算法取得进展）\n一个接收者在一个ballot下可以最多给一个值投票。一个值在一个ballot下被选择，当且仅当一组法定人数的接收者已经在这个ballot下为这个值进行了投票。\n我们说这个值在一个ballot number下是安全的，如果没有其他值在一个比当前ballot number小的ballot number下被选择或者曾经能够被选择\n该算法保持以下属性\nP1. 一个接收者只有当 v 在ballot b 是安全的，才能够在ballot b 给一个value v 投票\nP2. 不同的接收者不能在相同的ballot下给不同的值投票\n这些性质通过一个ballot b的领导者选择一个在ballot b 下安全的value v以及邀请接收者在ballot b下为这个值投票。一个接收者只有在接受到这样的请求时才会进行投票（当且仅当还没有对任何更高的ballot进行操作）一个ballot b有两个阶段需要进行。\nPhase 1a. ballot-b的领导者发送1a信息给接受者\nPhase 1b. 一个接收者用一个包含它所投的最高ballot和与之相对应的v回复给领导者；或者回复自己还没有投票\nPhase 2a. 根据收到的来自quorum个接收者的1b信息，领导者可以选择一个安全的value v，并将它作为2a信息中的待投票值\nPhase 2b. 接收者基于来自领导者的2a信息，一个接收者通过发送2b信息来在ballot b为v投票\n在Phase 2a的行动中，领导者必须从quorum个1b信息中决定一个安全的值，它通过遵从算法的下列属性来达成这一目的。\nP3a. 如果quorum个接受者现在没有给一个比当前ballot小的值投票，那么所有值在当前ballot下都是安全的\nP3b. 如果在quorum个1b消息中已经有一些接受者投票了，那么选择小于ballot b中最大的ballot c, 在ballot c中投出的值v在ballot b是安全的。(根据P2，这样的值只有一个)\n我们仅仅指出要满足活性的性质，ballot-b的领导者要能够在Phase 2a阶段从quorum个接受者的ballot-b 1b信息中决定一个安全的值。（活锁就是两个proposer因为没有收到足够的ballot-b 1b信息而持续race ballot导致的,如果这里我们陈述有leader,那么就不存在活锁，如果我们能正确地选择safe value,即使会偶尔出现faulty leader,我们也可以预见在有限的轮数内能够完成quorum acceptor接受相同的值，从而reach quorum）\n3. Byzantizing An Algorithm 我们通过让N个接受者在有f个假装接受者的情况下模拟一个共识算法，来对其进行拜占庭化。同时不是接受者的进程也可能是拜占庭的，特别是一个拜占庭化的Paxos算法必须能够容忍恶意的领导者，然而一个无恶意行为的领导者是满足活性所必要的。\nemulation意味着执行一个操作，在refinement mapping下，该操作是emulated algorithm的操作。refinement mapping将emulating system (the implementation)的每个状态映射到the emulated one (the specification)的一个状态。\n我们提前假设哪一个进程可能是恶意的，因为拜占庭化的算法假设我们对于谁是real的接收者和谁是fake的接收者一无所知，所以这样的假设结果不会损失一般性。此外，由于恶意进程可以做任何事情，包括像非故障进程一样行事，我们可以通过假设正好有f个fake的接受者从一开始就是恶意的，来证明该算法可以容忍至少f个恶意接受者。\n我们将 byzacceptors 的集合定义为real和fake接受者集合的联合。我们将byzquorum 定义为一个保证包含 a quorum of real acceptors 的 byzacceptors集合。如果一个quorum由任何q个接受者组成，那么一个byzquorum由任何q+f个byzacceptors组成。为了保证liveness，我们需要假设所有real接受者集合（我们假设它们永远不会失败）能够形成一个byzquorum.（此处和之前一样）\n在拜占庭化的算法中，一个非故障进程必须确保其模拟中的每个动作都能够在原始算法下被执行。\nPaxos共识中的关键行动是领导者的第2a phase的行动，它根据属性P3a和P3b选择一个安全值\n领导者可以推导出P3a成立，如果它收到byzquorum个1b消息并且断定他们的发送者没有进行投票（因为byzquorum包含quorum的接收者）\nP3b可能会出现问题。在拜占庭化的算法中，我们无法决定一个1b消息是来自real还是fake的接受者。一个可以保证安全性的方式是要求被选择的拥有最高ballot number的值来自f+1个byzacceptors。但这样严苛的要求会使我们丧失活性，因为可能存在这样一种状态：因为有的real接受者还没有投票，所以我们收到的f+1个来自real接受者的1b消息并没有都投票给同一个值 ！（这个时候我们还是在N \u0026gt; 2f的情况下考虑问题，保证了安全性，但没有保证活性。换句话说，为了保证协议的活性，我们在收到一定数量的1b消息后必须做出抉择）\n一个解决这个问题办法是假设N \u0026gt; 3f。在这种情况下我们能在收到更多数量的1b消息后再做出抉择，并且同时还保证了活性,此时任何两个quorums有至少f+1个公共的接收者。这个时候因为增加了N的数量所以quorum也被增加为至少2f+1\nP3a和P3b将会被替换成。\nP3a‘ 如果f+1个ballot c小于b的接受者还没有投票，那么所有值在ballot b都是安全的。\nP3b’ 如果f+1个ballot c小于b的接受者已经投票，那么这个ballot c对应的值在ballot b是安全的。\nPhase 2a只有在收到了byzquorum个1b消息才能进行，如果P3a‘没有成立，那么我们就可以应用P3b’,然而这是不满足的因为这会导致我们需要多于4f个接受者。（因为为了满足活性，那么我们收到的2f+1个消息后就要做出决定，但是这2f+1个消息可能可以被分为三种类型：1.投票给上一个ballot的安全值。2.未投票。3.伪造的投票。因为在考虑安全性时我们没有任何同步假设，即消息可能丢失，所以我们存在这样一种状态：第三种消息在2f+1个1b消息中的比例等于第一种消息且未投票的接受者数量不满足P3a‘，这个时候我们难以做出抉择！（例子：在收到的2f+1个1b消息中有f个fake vote，f个real vote, 1个no vote）更简单地说，因为之前接受者不会撒谎，所以出现在1b消息中的值是唯一的，而此时接受者是拜占庭的，所以。所以为了能够表决出伪造的投票，我们需要增加quorum的数量，我们需要让quorum 中至少有f+1个1b消息投给相同的值(no vote/a value voted)以帮助proposer做出决定，此时 quorum至少为2f+1个来自real接受者的1b信息可以帮我们在正确的值中做出抉择（no vote/a value voted），再加上f个来自fake接受者的1b信息，所以此时 byzquorum至少为3f+1 个1b消息。同时为了满足活性，所以需要至少4f+1个接受者。（Lamport这部分直接一笔带过,所以这部分的例子和推导是我自己想的，不保真但是可以说服我自己！）这里用于shrinkN \u0026gt; 4f的解决办法是杜绝接受者撒谎，后面会解释！\n这里还有另外一个问题。为了能够使Phase 2a能够进行，leader也不能发送不同的2a消息。如果P3a’成立，一个恶意的节点可能发送两种不同的2a消息，这可能导致两种不同的值在两个之后的ballot中被选择。\n解决leader欺骗的方法是让leader和acceptors合作模仿Phase 2a的执行，使用一个新的Phase 2av行动。 领导者leader发送为一个特定的值v执行Phase 2a的请求给byzacceptors。一个接受者通过执行一个发送关于value v的2av消息给所有byzacceptors的Phase 2av行动来响应这个请求。一个byzacceptor执行Phase 2av, 只有当\n它能决定这样的一个2a消息在算法中能够被发出。\n在当前的ballot中，它还没有执行Phase 2b行动。\n一个接受者可以执行Phase 2b行动，如果它收到byzquorum个有同一个值的2av信息。由于任意两个byzquorums有至少一个公共的real acceptor, 所以没有两个real接受者会因为各自收byzquorum个两个不同的值，而执行不同的Phase 2b行动（为不同的值投票）。\n(这部分对应PBFT中阶段的关系是Pre-Prepare+Prepare: Phase 2av; Commit: Phase 2b)\n4. Algorithm PCon 这个章节介绍一个我们称之为PCon经典Paxos共识算法的变体。就像经典的Paxos，它假设N个接受者（N \u0026gt; 2f+1）\n在上面描述的经典Paxos算法中，一个ballot-b 2a消息有两个功能：\n（1）它断言这个值在ballot-b是安全的。\n（2）它指示接受者们在ballot-b为这个值投票。\n在算法Pcon中，我们引入1c消息来实现（1），同时我们运行leader发送多个1c消息去断言多个值是安全的。我们引入了Phase 1c和Phase 2a.\nPhase 1c. 使用来自quorum个接收者的1b消息，leader选择一组在ballot b安全的值，同时为每一个值发送一个1c消息。\nPhase 2a. leader为一些已经为它发送了1c消息的值发送一个2a消息。\nleader不需要一次性发送所有的1c消息；它能使用单个ballot执行Phase 1c行动多次。而对于如何在Phase 1c行动中选择一个安全值，ballot-b的leader从quorum个接受者处收到1b消息后，用如下情况进行选择。\nP3a. 如果quorum个接受者现在没有给一个比当前ballot小的值投票，那么所有值在当前ballot下都是安全的\nP3c. 如果一个值为v的ballot-c消息在Phase 1c被发出，对于c \u0026lt; b。1. quorum个接受者现在没有为任何大于c小于b的ballot投票。 2. 这quorum个接受者的任何一个在ballot-c进行了投票且都投票给了v，那么v在ballot-b就是安全的\nballot-b的leader应该将1c消息发送给谁？以及它如何知道在lower ballot被发出的1c消息是哪些，从而检查P3c是否成立？在PCon中，1c消息是逻辑构造的，而不需要实际发送。发送一个2a消息意味着必要的1c消息已经被发出，一个报告在ballot c投票的1b消息意味着一个ballot-c 1c消息必须被发出过。（也就是如果一个1b消息报告在某个ballot给某个值投了票，如果这个1b信息是安全的，那么曾经应该有一个与之这个值对应的1c信息在某个更小的ballot被发出过） 既然这个1c信息是我们逻辑构造的，那么我们为什么要在之前的算法中引入他呢？\n系统不可能基于一个固定的接受者集合长时间地运行。接受者可能被移除和添加——一个叫做reconfiguration的程序。在经典的Paxos中，reconfiguration发生在共识实例间，单实例能够有效地被单个固定的接受者集合执行。现在已经有算法提出在单个共识实例地执行间进行reconfiguration，使用不同的ballot和可能不同的接受者集合：Vertical Paxos和未发表的Cheap Paxos（2023年了不知道发表了没有= =！）1c消息的作用是消除对于lower-numbered ballots接受者的依赖，它们可能已经被reconfigured out了(比如一个接受者接受了，但他被移除出了系统)。 当一个新的活跃leader开始ballot b时，情况P3a适用于ballot b第二阶段阶段尚未开始的无限多个实例。leader的1c消息可以通知未来的leader这个事实，因此，他们不必了解在编号小于b的ballot中的投票情况。（有点没懂，翻译也看不明白！但是按照我的理解就是未来的leader可以靠1c知道任何在比b小的ballot的投票情况？好像有道理，未来的leader是现在的acceptor,那么因为现在的acceptor收到了1c信息，那么未来如果它成为leader，它就能够根据之前收到的1c信来检查P3c的情况是否成立）\n根据定义，如果两个不同的值在ballot b是安全的，那么所有的值在ballot b都是安全的。 除了发送消息说一个单一的值是安全的，或者发送消息说所有的值都是安全的，领导者没有理由做任何其他事情。\n5. Algorithm BPCon 我们现在派生出算法BPCon通过拜占庭化N-acceptor算法PCon以及添加f个fake接受者。我们先考虑一个leader进程的行动。leader在算法BPCon中没有明确的2a消息或者Phase 2a行动。取而代之的是，接受者合作模仿2a消息的发送。ballot-b的领导者要求对已经发送过1c消息的值v进行2a阶段的操作。在收到第一个这样的请求后，一个接受者执行一个Phase 2av行动， 为value v发送一个ballot-b 2av消息。前提是它已经收到一个关于这个值的合法的ballot-b 1c\n因为leader的请求只对liveness是必要的，我们不刻意地去建模它。取而代之，我们允许一个接受者去执行一个ballot b的Phase 2av行动当且仅当它已经收到了必要的1C行动，并且还没有发送一个 ballot-b的2av消息。\n因为算法必须容忍恶意的领导者，我们让ballot-b的领导者能够发送任意它像发送的1a和1c消息（牢记我们不能发送一个看似是其他人发送的消息）。ballot-b 1a消息在PCon中只有一种可能性，同时被允许在Phase 1a行动的任何时间发送。于是在BPCon的Phase 1a行动中与PCon的Phase 1a一致。BPCon的phase 1c行动允许ballot-b的领导者在任何时候去发送任何ballot-b的1c信息。\n接受者将会忽略非法的1c消息。为了保证活性，一个无故障的领导者必须发送一个real接受者能够响应的消息。我们必须确定接受者如何知道一个1c 信息是合法的。\n在PCon中，通过上述P3a或P3c启用投票-B 1c消息的发送，这需要从一个法定人数中收到一组1b消息并可能收到一个1c信息。在BPCon中，我们将额外信息放入1b消息中使能够进行1c消息已经被发送的推导。一个接受者将所有它发送过的2av消息作为集合装进1b消息中——对每一个值，它只将它为这个值发送的最高ballot的2av消息放入其中。这些被发送的2av消息中的每一个都对应一个合法的1c消息。 如同我们在第三节中关于拜占庭化的讨论,这意味着给定一组来自byzquorum关于ballot b的1b消息S，以下两个条件分别对应之前的P3a和P3c：\nBP3a. 每个在S中的消息都断言它的发送者还没有投票。\nBP3c. 对一些c \u0026lt; b和一些值 v, (a)每个在S中的消息都断言 (i)它的发送者没有在任何大于c的ballot投票以及 (ii) 如果它在ballot-c的投票是v， 且(b)有f+1个来自byzacceptors的1b消息表明它们在ballot-c发送了关于value v的2av消息\n稍微思考一下就会发现我们可以弱化BP3c关于条件(b)断言：\n(b\u0026rsquo;) 如果存在f+1个来自byzacceptors的1b消息表明他们在一个大于或等于c的ballot发送了关于value v的2av消息\n去决定是否一个1c消息是合法的，每个接受者维护一个他们知道的已经发送了的1b消息的集合。 我们的抽象算法假设一个行动nondeterministically将实际发送的1b消息的子集添加进这个集合。当然，一些1b消息可能来自fake接受者。活性要求领导者确保接受者最终知道允许领导者发送 1c 消息的 1b 消息已发送\n如前面讨论的，当它从quorum个接受者收到相同的2av消息，一个接受者才能执行Phase2b行动。一个PCon的2a消息被一组被quorum发送的相同的2av消息模拟，同时Phase2a被这组相同的2av消息中最后被发送的那条信息所模仿（代表）。\n6. 关于被发送消息的活性和学习 PCon的活性要求一个无故障的领导者执行一个ballot b时没有另一个leader开始一个更高的ballot,同时leader和无故障的接受者能互相通信。BPCon的活性要求和PCon也是一样的。然而。这很难去确保一个拜占庭的领导者不执行一个更高的ballot。解决这个问题需要一些基于实时假设的工程解决方案。\n假设这些要求，BPCon的活性要求满足以下两个条件：\nBL1. 领导者能找到满足BP3a或者BP3c的1b消息。\nBL2. 全部真的接受者将知道那些已经被发送的消息。\n这两个条件意味着领导者将发送一个合法的1c消息，byzquorum的real接受者将收到1c消息以及发送2av消息，所有在byzquorum的接受者将收到哪些2av消息以及发送2b消息。学习者根据收到的这些2b消息将会学习到被选择的值。\n为了证明BL1成立，ballot-b的领导者最终会从BQ的接受者们那里收到1b的信息。让S记作这些1b消息的集合。我们现在证明BP3a或者BP3c成立。\n只要假设BP3a是假的，并证明BP3c就可以了。\n令 c 为 BQ 中的接受者投票的最大ballot，令 a 为这样的接受者，并令 v 为其投票的值。\n证明：由1的假设可以得出存在这样一个 c。\n接受者a收到来自byzquorum的在ballot-c的关于值v的2av消息。\n证明：通过2以及Phase2b行动的启动条件。\n没有其他接受者在ballot c给其他不是v的值投票。\n证明：通过2可以证明，因为任何两个byzquorums由一个公共的接受者，以及一个接受者最多发送一次ballot-c的2av消息。\n至少f+1个接受者发送关于值v的ballot-c 2av消息。\n证明：通过3证明，因为一byzquorum包含至少f+1个接受者。\nBP3c的条件(b‘)成立。\n证明：通过5，因为一个发送一个关于value v的ballot-c 2av消息的接受者意味着，对于b \u0026gt; c，它的ballot-b 1b消息将会报告它在某些大于等于c的ballot发送过一个关于value v的2av消息。\nBP3c的条件(a)成立。\n证明：通过2(没有在BQ中的接受者在大于ballot-c的ballot投票)，以及4\nQED。\n证明：通过1，6和7。\n这表明 BL1 最终成立。 为了证明活性，我们需要证明 BL2 成立。 为了确保它成立，领导者必须有办法确保所有真正的接受者最终都知道发送了 1b 消息。 如果 1b 消息是由真正的接受者发送的，那么该接受者可以将其 1b 消息广播给所有的byzacceptors以及领导者 我们现在提出两种方法来确保接受者知道发送了 1b 消息，即使它是由假接受者发送的。\n6.1 发送证明 最简单的方法是领导者在其 1c 消息中包含一个证明，证明所有必要的 1b 消息都已发送。 最简单的方法是使用完整的数字签名并让 byzacceptors 签署他们的 1b 消息。领导者可以在其 1c 消息中包含必要的正确签名的 1b 消息。\n还可以使用MACs。一个MAC是一个签名Mp-\u0026gt;q，一个进程p能够附带在一个消息m上，向进程q证明p发送了m。MAC Mp-\u0026gt;q不能向除了q以外的其他进程证明任何事。\n假设一个消息m断言一个确定的事实，一个进程q收到这个消息以及从f+1个不同的进程p的MAC Mp-\u0026gt;q。因为最多有f个拜占庭进程，他们中的至少一个进程的断言是真的。然而，q不能向其他任何进程证明这个事实是真实的。然而，假设它从2f+1个进程收到一个MACs的向量向量\u0026lt; Mp-\u0026gt;r1, \u0026hellip;., Mp-\u0026gt;rk \u0026gt;以及这个消息。向量中的至少f+1由无故障进程p发送，所以他们有正确的MACs以及能够说服对应的ri进程有一个无故障的进程发送了M。因此，q能够发送消息m以及这样的MACs的2f+1个项的向量给每个进程ri作为m的断言的证明。\n6.2 中继1b消息 我们现在描述另一个方式能确保好的接受者知道1b消息被发送了（接受者最终知道允许领导者发送 1c 消息的 1b 消息已发送）。我们让byzacceptors广播他们的1b消息给所有的byzacceptors（包括领导），同时让他们中继这个1b消息给他们的领导者以及其他byzacceptors。根据收到来自2f+1个byzacceptors的1b消息，领导者知道至少f + 1个真的接受者发送或中继给了所有byzacceptors。假设对活性的要求，这意味着所有的接受者最终都会从 f +1 个不同的的byzacceptors那里收到 1b 消息的副本（因为f+1个真的接受者会根据协议广播，并中继别人的1b消息），从中它推断出消息确实被发送了。（由其他人转发代表真的广播了）\n这是Castro和Liskov使用的基本方法。 然而，在他们的算法中，byzacceptors 仅将广播的 1b 消息（他们称为 view-change-acks）转发给领导者（他们称为primary）。 领导者在其 1c 消息中包含（摘要）1b 消息，并且接受者要求其他 byzacceptors 中继 1c 消息中它尚未收到的任何 1b 消息。\n7. Castro-Liskov算法 Castro-Liskov算法，就像Paxos，运行一个状态机通过执行一个有无限实列的共识算法。它包含对于处理实例的顺序的工程优化，特别是对于旧实例的垃圾收集，以及对于修复进程的状态迁移。我们认为，这些优化可以通过对经典Paxos的相应优化进行拜占庭化来获得，但是他们与共识无关。一些其他优化，比如不发送完整信息而是发送消息的摘要，是一些我们为了简单起见而忽视的细节。\n当我们忽视这些细节，只关心Castro-Liskov的共识算法本身，我们剩下的是一个完善BPCon的算法。在Castro-Liskov算法中，byzacceptors被叫做replicas。 ballot-b的领导者叫做primary，其他byzacceptors被叫做backups。replicas也被称作学习者。 我们通过描述 BPCon 的消息是如何实现的来解释 Castro-Liskov 共识算法是如何改进 BPCon 的。\n1a 没有明确的1a消息；当复制体决定开始view change时，其发送是由复制体合作模仿的。\n1b view-change消息。\n1c 在view change期间，new-view消息对所有共识实例来说就像1c信息一样。 对于一个primary指示replicas去选择一个特定值的实例，它是具有该值的 1c 消息。 对于所有其他实例，它是所有值的一组 1c 消息。 （条件 BP3a 在那些其他实例中成立。）接受者同时为所有实例检查这些 1c 消息的有效性。\n2av 这是一个backup的prepare消息。primary的pre-prepare消息serves as 2av消息以及请求一个Phase 2a行动\n2b 这是Commit phase\n如同在6.2节中解释的一样，Castro-Liskov算法的view-change-ack被用作中继1b消息给领导。它的reply消息被replicas发送，作为learners去通知client被选择的值。\n我们在第 3 节中解释了拜占庭经典 Paxos 的困难。 我们无法从经典的 Paxos 中获得 Castro-Liskov 算法并不是拜占庭化的缺陷； 这是因为该算法没有对经典的 Paxos 进行细化——至少，在任何简单的细化映射下都没有。 在 Castro-Liskov 共识算法中，领导者可能需要预先准备一个值 v，即使在之前的视图中没有副本提交过 v。 这在经典的 Paxos 中是不可能发生的。\n","permalink":"/posts/read/byzantizingpaxos/","summary":"之前对于Byzantine Paxos的理解完全建立在Youtube上Mu Shuai老师的讲解视频上，现在决定好好读一遍Lamport老爷爷的","title":"ByzantizingPaxos"},{"content":"有许可区块链是一种分布式账本技术（DLT），它牺牲了一定程度的去中心化和匿名性，以更好地适应商业需求，以及实现更高的网络速度和效率。\n在这篇文章中，我们将介绍无许可区块链和有许可区块链，同时探讨这两种DLT解决方案之间的核心差异。\n什么是区块链网络？ 在我们深入探讨我们的主题之前，让我们首先重温一下区块链技术的基本知识。\n随着比特币的推出，区块链是一个数字账本，它被复制并分布在网络中所有参与者的设备上。\n因此，区块链的每一个变化都会实时透明地记录在所有参与者的账本上。这意味着，网络中的每个人都会看到一个具有相同记录的分布式账本，允许用户审计和追溯交易。\n在传统网络中具有正确访问级别的个别参与者可以对服务器的数据进行修改，但区块链网络中验证者必须通过工作证明（PoW）或取证（PoS）等机制达成共识，才能更新区块链。\n由于这个原因，一旦某件事被记录在分布式账本上，单个用户就不能修改、删除或篡改数据，这使得区块链在本质上是不可改变的。\n此外，区块链通过庞大的计算机网络来维护生态系统，消除了单点故障。\n由于分散在世界各地的数千台（甚至数百万台）设备向链上添加新的区块并验证交易，区块链对网络攻击更加安全，因为黑客必须接管网络的大部分（而不是单一的服务器）才能获得控制权。\n所有的交易都通过公钥加密技术进行加密，因此区块链网络可以没有第三方或中间人的情况下连续运行。\n什么是无许可区块链？ 例子: Bitcoin, Ethereum, Litecoin\n无许可区块链是加密货币社区用户最熟悉的DLT技术类型。\n这不应该是一个惊喜。\n比特币、以太坊和大多数加密货币的底层区块链网络都使用这种形式的分布式账本。\n在一个无许可的区块链网络中，任何人都可以参与并成为验证者。\n例如，如果你有一个兼容的设备和一个工作的互联网连接，你可以自由地创建一个比特币钱包，甚至通过成为一个矿工来维护这个网络。\n无许可的区块链网络完全缺乏访问控制。\n因此，普通用户和验证者都不需要验证他们的身份或提交了解你的客户（KYC）文件来加入。相反，他们可以在保持匿名或假名的情况下参与网络。\n无许可区块链的好处是什么？ 去中心化: 由于对验证者没有访问控制或限制，无许可区块链网络是真正的去中心化。每个参与者都是平等的，没有人可以对其他人行使更大的权力。\n加强安全保障： 对验证者没有限制，激励了更多的参与者来维护区块链。出于这个原因，大多数无许可账本都有大量的验证者，增强了网络的安全性。\n隐私： 由于参与者不需要提供任何个人资料或文件来加入，无许可区块链的特点是增加了隐私，允许用户在与网络中的解决方案互动时保持匿名或假名。\n社区自治： 大多数无许可区块链不是由公司、政府或其他中心化实体管理，而是由项目的社区管理。\nCensorship resistance： 由于高度的去中心化和大量的验证者，permissionless blockchains are effectively resistant to censorship.\n无许可区块链的缺点是什么？ 有限的速度和可扩展性：由于它们具有大量的验证者，他们都需要达成共识来处理转账和向链上添加新的区块，因此无许可区块链经常面临着可扩展性和交易吞吐量有限的问题。\n链条分裂的风险: 在无许可的区块链网络中，社区必须紧密合作以维护生态系统。然而，矿工之间的激烈辩论和分歧会分裂社区，也会在硬分叉（与之前版本不兼容的重大升级）期间分裂区块链。\n能源效率问题: 比特币、以太坊和许多其他主要区块链为达成共识而部署的工作证明（PoW）算法是高度能源密集型的，因为矿工需要操作物理设备来解决复杂的数学难题。因此，BTC挖矿消耗的能源比瑞典一年的能源还要多。也就是说，许多无许可区块链正在将其共识机制升级为更节能的算法（例如，Proof-of-Stake），以解决此类问题。\n恶意活动的风险: 虽然大多数无许可区块链可以有效地防止黑客攻击，但它们不能防止网络犯罪分子进入网络并针对生态系统中的解决方案。\n什么是许可的区块链？ 例子： ConsenSys Quorum, Hyperledger Fabric, R3 Corda\n与无许可区块链相反，有许可的区块链是一种DLT解决方案，对验证者进行访问控制。\n这可能意味着设置一个要求，要求网络中的所有验证者提供KYC文件。\n另外，在大多数情况下，管理许可账本的组织或社区会选择用户来验证生态系统中的区块。\n此外，许可区块链限制了网络中验证者的最大数量，以提高效率，并实现更高的吞吐量和可扩展性。\n虽然有些许可区块链对标准用户也有访问控制，但其他区块链只限制谁可以成为验证者（后面会详细介绍）。\n与迎合大众的无权限区块链不同，有权限的区块链更适合企业使用，因为它们可以更容易地定制，以适应个别业务需求。\n许可区块链的好处是什么？ 增强的可扩展性和速度： 许可区块链的特点是只有少量的验证者。因此，它们可以比无权限的同类产品更快地达成共识，同时实现高可扩展性和速度。\n可定制性： 通过对验证者的访问控制，管理许可区块链的企业可以设置自己的规则，并定制网络以最适合他们的需求。\n遵守规定: 许可账本为企业提供了对网络基础设施的更多控制，这使他们能够更有效地履行合规要求。\n有限的恶意存在： 通过对验证者的有效访问控制，许可的区块链可以有效地消除（或至少限制）生态系统中恶意方的存在。\n成本有效： 少量的验证器提高了可扩展性和吞吐量，并降低了网络运营的成本。\n许可区块链的缺点是什么？ 增强的中心化： 由管理链的组织或社区选择，只有数量有限的验证者可以参与到许可网络中。虽然去中心化的程度因网络而异，但有许可的区块链比无许可的区块链更中心化。\n低透明度： 有许可的区块链的透明度是基于组织本身进行怎样的管理。虽然一些企业可能决定保持与无许可区块链相同的透明度，但一些企业不愿意与参与者分享其流程和程序的信息。\n隐私性下降： 由于验证者\u0026ndash;在某些情况下也包括标准用户\u0026ndash;必须通过KYC，所以有许可的区块链的特点是隐私有限，使得大多数参与者几乎不可能以假名方式使用网络。\nNo resistance against censorship： 由于网络是由一个必须遵守法规的组织管理的，因此许可区块链在某些司法管辖区可能会受到审查。\n潜在的安全问题： 通过适当的访问控制，许可的区块链可以在其网络中保持高水平的安全。然而，由于验证者的数量较少，恶意的一方比无许可的账本更容易渗透到有许可的区块链中。\nPermissioned vs. Permissionless vs. Public vs. Private Blockchains Public和permissionless，以及private和permissioned，是加密货币领域的区块链解决方案经常互换使用的概念。\n然而，public和无permissionless以及private和permissioned的区块链之间存在着重大的区别。\npermissioned和permissionless是用来描述DLT网络是否对验证者有访问控制的短语whether has access controls in place for validators。简单地说，这些链的类型有不同的access规则。\n任何人都可以成为permissionless中的验证者，但用户必须通过KYC检查和通过投票程序来验证permissioned网络中的区块。\n然而，上述两种表达方式并不包括区块链是否开放给标准用户参与。\n当一个区块链是public，任何人都可以访问网络并审计分布式账本上记录的数据。从本质上讲，所有permissionless链都是公开的。\n另一方面，private链只允许选定的用户进入网络。在大多数情况下，只有那些已经通过KYC检查并得到管理员批准的人可以加入。Private DLT解决方案限制了用户的access权限。没有权限的人既不能查看链上的数据，也不能成为网络中的验证者。出于这个原因，所有的私有区块链也是有权限的。\n另一方面，市场上有public permissioned 区块链，允许任何人查看账本上的记录并与网络内的解决方案互动，但有措施限制谁可以验证区块。\n[1] Permissioned vs. Permissionless Blockchains Explained\n","permalink":"/posts/tech/permissionedorless/","summary":"有许可区块链是一种分布式账本技术（DLT），它牺牲了一定程度的去中心化和匿名性，以更好地适应商业需求，以及实现更高的网络速度和效率。 在这篇文","title":"[翻译]Permissioned vs. Permissionless Blockchains Explained"},{"content":"Problem In general blockchain, every single node is required to replicate, validate, store and maintain the states of all users in entire network.\nSolution This paper present a idea to divide the blockchain into different asynchronous consensus zones (multi-instanitiation of independent blockchain systems). Partitioning workloads of the entire network, distribute to zones. Parallelize blovk creation and transaction handling since we have multi-independent blockchain. To achieve linear scalability as the entire network is divided into more zones.\nBackground The system presented by this paper use Account/Balance transaction models and PoW. This paper uses the account/balance model due to its simplicity since a transaction with an arbitrary amount can be performed with one sending account and one receiving account. Another important benefit offered by the account/ballance model is allowing transactions to carry incremental updates of states, as oppose to the UTXO transactions that can only carry full states.\nSystem Design\rHandling a payment that involves two users from different zones example:\nThe withdraw oper\u0002ation ρ that only involves the state in zone A is handledby a miner in zone A. If the account balance satisfiesthe cost of this withdraw operation, the corresponding block t + 1 carrying the transaction (initiative transac\u0002tion) will be created by the miner and only be appendedto the chain of zone A. After that, a relay transactioncarrying the deposit operation φ is composed in zone Aand forwarded to zone B. The deposit operation φ thatonly involves the state in zone B can always be executed,regardless of the balance of the target account in zone B.Once the relay transaction is picked up by another minerin zone B, operation φ will be executed, concluding thecomplete of the payment transaction.\nPartitioning and Naming The account of user is represented by its address(a fix-sized hash value of its public key). Uniformly partitioning the space of user address into 2 power to k zones: a zone is identified by its sharding scale k and zone index s.\nThe zone index of an initiative transaction is determined by the payer\u0026rsquo;s address, and the zone index of a relay transaction is determinated by the payee\u0026rsquo;s address.\nIn the system of paper, full nodes join swarms to broadcast new transactions and receive blocks from other full nodes. A swarm is a group of nodes that participate in the replication of the same data set. For example, in Bitcoin or Ethereum, there is only one swarm and every full node replicates the same dataset, including all blocks and transactions. In the system of paper, there is a global swarm which joined by all full nodes for replicating the minimum common information of all zones. the most communication occurs in zone-specific swarm with full nodes belonging to specific zones only. In each swarm, the participating full nodes are sparsely connected, and use the gossip protocol to broadcast message.\nIsolated Intra-Zone Workload A full node, or a miner, will have a persistent identifier that is initialized randomly. With address space partitioning, a blockchain is established within each zone independently. Only care about their own zone! They should ignore any blocks or transactions received that do not belong to their zone(although those are unlikely to be received).\nMinimized Cross-Zone Overhead In a blockchain system, most communication is for replicating unconfirmed transactions and for broadcasting new blocks carring confirmed ones. But since now we have isolated zones, so the most communication is performed only among nodes within the zone. Each node maintain a DHT to help them find the specific zone for their peers. After getting the zone index s of an unconfirmed transaction or a forwarding block, system selects out nodes having the same zone index as s based on the lcoal DHT routing table, and it sends the transaction and block to these nodes following the gossip protocol. This way help to minimized data for chain forming excluding actual confirmed transactions are replicated across all zones (what is the actual confirmed transactions?)\nContribustion\nContribution Efficient Cross-Zone Atomicity Chaining-block a pointer to the precursor block\na PoW nonce\na Merkle tree root of the list of confirmed transactions\na Merkle tree root of the list of all relay transactions originated from initiative transactions in this block, which is used for the validation of relay transactions in other zones.\nDual-stage transaction handling mechanism By deriving and forwarding a relay transaction that carries the deposit operation to its destination zone.\nTransaction Validation and Forwarding at Zone A\nA miner pick up a unconfirmed transaction when they are constructing a new block.\nThe initiative transaction is validated if the balance of a is less than the transfer amount, this transactin wil be marked as invalid, and be concluded and embedded in the block.\nOtherwise, a chaining-block and a transaction-block are constructed. Transaction-block has a list of validated transactions including the one from a to b.\nThe miner work on the PoW puzzle specific to the list of all confirmed transactions.\nAfter the PoW puzzle is solved, the chaining-block is broadcast in the global swarm and the transaction-block is broadcast in a\u0026rsquo;s zone-specific swarm.\nWhen the other nodes wihtin this zone received the transaction-block, the intra-zone transactions are executed and concluded. The withdraw operation in all cross-zone transactions are then executed(on the other zones).\nEach cross-zone transaction derives an outbound relay transaction, which will be sent to the destination zone.\nRelay Transaction Handling at Zone B\nAn inbound relay transaction is picked up by a miner in payee b\u0026rsquo;s zone when constructing a new block.\nThe miner verifies the inbound relay transaction against its originate block. Skip this if invalid.\nThe miner constructed a new chaining-block and a new transaction-block including the inbound relay transaction.\nAs same as before the chaining-block will be broadcast in global swarm and the transaction-block will be broadcast in b\u0026rsquo;s zone after the PoW puzzle is solved.\nThe deposit operation is executed, concluding the transaction.\nVerification Let\u0026rsquo;s skip this part and regard it as a black box to use!!!\nEventual Atomicity A payment transaction involving withdraw and deposit operations, should be atomic to ensure corrrectness of the global ledger!!!\nRSCoin and OmniLedger use two-phase commit mechanism to ensure the atomicity, with the known lock/unlock overhead.\nIn this system, for a cross-zone trnsaction, allow the withdraw operation to execute first, then the the corresponding deposit operation to be settlled later. They call such an atomicity, eventual atomicity.\nTheir design ensures is that relay transactions will not be discriminated by sufficiently incentivizing with a fee split.\nfee split: incentivize both miners working on initial step and relayed step of transaction handling\nA rational miner prioritizes unconfirmed transactions based on the transaction fee. This paper introduce fee splitting for cross-zone transactions. The author recommend cross-zone transaction issuer set double or even triple the amount of transaction fees to make sure the relayed transactions can be prioritized with transaction fee after fee split.\nWe introduce fee splitting for cross-zone transactions,which incentivize both miners working on initial step andrelayed step of transaction handling so that relayed trans\u0002actions will be equally prioritized with transaction feesat similar levels 最后一句陈述的意思是处于similar level(worklaod 类似)的initial step of transactions和relayed step of transactions能够平等地根据transaction fee来区分优先级。\nIn the existing blockchain system, a payment transac\u0002tion will be visible to its payee once it is packed in ablock on the chain (first confirm). It will be secured aftern − 1 successive blocks appended (n-th confirm, n = 6in Bitcoin and 12 in Ethereum). In contrast, a cross\u0002zone payment transaction in our system will be visible to the payee, once its relay transaction is forwarded to thepayee’s zone, and its originate block becomes available.With the eventual atomicity, the transaction is consideredas eventually secured, once its initiative transaction gets n-confirmed, and the relay transaction gets a first confirm. (这一段是关于可见性的)\nFork Resolution Let\u0026rsquo;s skip this part!!!\nMining Power Diluted with Multiple Zones Skip this part now!\n[1] nsdi19-wang-jiaping.pdf (usenix.org)\n[2] Monoxide: Scale out Blockchains with Asynchronous Consensus Zones | USENIX\n","permalink":"/posts/read/monoxide/","summary":"Problem In general blockchain, every single node is required to replicate, validate, store and maintain the states of all users in entire network. Solution This paper present a idea to divide the blockchain into different asynchronous consensus zones (multi-instanitiation of independent blockchain systems). Partitioning workloads of the entire network, distribute to zones. Parallelize blovk creation and transaction handling since we have multi-independent blockchain. To achieve linear scalability as the entire","title":"Monoxide: Scale out Blockchains with Asynchronous Consensus Zones"},{"content":"Abstract \u0026ldquo;Scaling blockchain systems under general workloads remains an open question\u0026rdquo;.\nThe challenges of scaling are different between databasebases and blockchain since they have different failure models.\nThe major contribution of this paper:\nEnhance the performance of Byzantine consensus protocols -\u0026gt; inprove the individual shard\u0026rsquo;s throughput.\nDesign an efficient shard formation protocol -\u0026gt; leverage a trsted random beacon to securely assign nodes into shards.\nDesign a general distributed transaction protocol -\u0026gt; ensure safety and liveness even when transaction coordinators are malicious.\nIntroduction The tradeoff between strong security and scalability (the consensus protocol blockchain systems have to rely on is scalable poorly)\non hardware aspect -\u0026gt; \u0026ldquo;trusted hardware has not been demonstrated on data-intensive blockchain workloads\u0026rdquo;\nsharding -\u0026gt; divide the blockchain network into small committees to reduce the overhead of consensus protocols\nThis paper extend sharding to permissioned blockchian systems\nBFT consensus protocols in trusted execution environment(TEE) Leveraing trusted execution environment to eliminate equivocation(provide different values to its neighbors) in the Byzantine failure model -\u0026gt; achieve higher fault tolerance with the same number of nodes [(n-1)/3 - \u0026gt; (n-1)/2].\nNo necessary to understand too many details\nEfficient shard formation protocol Leverage the TEE to design an efficient and secure shard formation protocol -\u0026gt; implement a trusted randomness beacon inside the TEE to generate unbiased random values in a distributed setting\nThe nodes derive their committee assignment by computing a random permutation pi [1 : N] seeded by rnd. pi is then divided into approximately equally-sized chunks, each of which represents the members in one committee. To exploit TEEs to efficiently obtain rnd. Each new epoch correspondings to a new node-to-committee assignment, nodes invoke the enclave with an epoch number e to generate two random values q and rnd. If and only if q = 0. \u0026lt;e,rnd\u0026gt; is broadcasted to the network. After a time theta, nodes lock in the loweast rnd they receive for current epoch e, then use it to compute the committee assignment.\nNo necessary to understand too many details (Committee size, Shard Reconfiguration)\nUTXO transactions Consists of a list of inputs, and a list of outputs. All the inputs must be the outputs of previous transactions that are unspent. The outputs of the transaction are new, unspent coins. (Given a transaction, its inputs are unspent and the sum of the outputs is not greater than that of the inputs, if two transactions consume the same unspent coins, only one is accepted)\nDistributed transactions!!! RapidChain exploites UTXO model to achieve atomicity but can not achieve isolation. And it also fails to work for non-UTXO distributed transactions, because it violates both atomocity and isolation.\nOmniLedger achieves safety for the UTXO model but remain the liveness issue.\nThe design of this paper:\nDesign a distributed transaction protocol that achieves safety for general blockchain transactions (non-UTXO) and liveness against malicious coorinators\nSafety: two-phase commit (2PC) and two-phase locking (2PL)\nLiveness: To guard against a malicious coordinator -\u0026gt; BFT reference committee serve as a coordinator\nThe BFT reference committee is also a shard which formulated by a certain number of nodes.\nThe client initiates a transaction tx by sending BeginTX request to the reference committee.\nPrepare: Once R has executed the BeginTx request, in other words, the quorum of nodes in the R have reached the consensus on this request. it enters \u0026ldquo;Started\u0026rdquo; state. Nodes in R then send PrepareTx requests to the transaction committees(transaction shard). The tx-committee will wait for a quorum of matching PrepareTx to ensure that BeginTx has been executed in R. The each tx-committee executes the PrepareTx. If consensus is reached that tx can be committed, which requires that tx can obtain all of its locks I am really comfused about this statement???), the nodes within the committee send out PrepareOK messages.\nPre-Commit: When entering “Started” state, R initializes a counter c with the number of tx-committees involved in tx:\nreceiving the quorum of matching responses from a tx-committee it will maintain the same state or enter a new state depend on the state machine input (PrepareOK or PrepareNotOK). (I am really comfused about how to regard a committee as a state machine!!! How keep the consistancy between nodes? Which node in the committee to deciede there is a quorum of matching response?)\nCommit: Once R has entered \u0026ldquo;Committed\u0026rdquo; state, the nodes in R send out CommitTx or AbortTx message to tx-committees. As same as before, the latter wait for a quorum of matching messages from R before executing the corresponding commit or abort operation.\n2PC and 2PL 2PC (used for distributed transactions): Two-phase commit is an algorithm for achieving atomic transaction commit across multiple nodes \u0026ndash; to ensure that either all nodes commit or all nodes abort.\n2PL (used for consistency and isolation in stand-alone transactions): provides serializable isolation\nGrowing: request locks\nShrinking: free locks\ndatabases often use an enhanced version of S(trong)S(trict)2PL, which is a little different compared to 2PL: the shrinking phase, which can only release the lock after the transaction is over, completely eliminates the uncommitted data of the transaction from being read.\nHow to handle dead-lock?\nDeadlock detection: database system draw the wait-for graph, dead-lock happens if there is a ring.\nDeadlock prevention: as requesting a lock that is already held, the database system kills one of the transactions to prevent deadlocks (generally the longer the transaction lasts, the higher the priority of the reservation). This prevention method does not require a waits-for graph, but increases the rate at which transactions are killed.\nReference [1] Towards Scaling Blockchain Systems via Sharding (arxiv.org)\n[2] 区块链相关论文研读7：通过分片（Sharding）扩展区块链 - 知乎 (zhihu.com)\n[3] Introduction to two-phase commit, Don\u0026rsquo;t confuse 2PC and 2PL (ebrary.net)\n[4] 一篇讲透如何理解数据库并发控制（纯干货） - 知乎 (zhihu.com)\n","permalink":"/posts/read/sharding1/","summary":"Abstract \u0026ldquo;Scaling blockchain systems under general workloads remains an open question\u0026rdquo;. The challenges of scaling are different between databasebases and blockchain since they have different failure models. The major contribution of this paper: Enhance the performance of Byzantine consensus protocols -\u0026gt; inprove the individual shard\u0026rsquo;s throughput. Design an efficient shard formation protocol -\u0026gt; leverage a trsted random beacon to securely assign nodes into shards. Design a general distributed transaction protocol","title":"Towards Scaling Blockchain Systems via Sharding"}]