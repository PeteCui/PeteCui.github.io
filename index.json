[{"content":"Abstract \u0026ldquo;Scaling blockchain systems under general workloads remains an open question\u0026rdquo;.\nThe challenges of scaling are different between databasebases and blockchain since they have different failure models.\nThe major contribution of this paper:\nEnhance the performance of Byzantine consensus protocols -\u0026gt; inprove the individual shard\u0026rsquo;s throughput.\nDesign an efficient shard formation protocol -\u0026gt; leverage a trsted random beacon to securely assign nodes into shards.\nDesign a general distributed transaction protocol -\u0026gt; ensure safety and liveness even when transaction coordinators are malicious.\nIntroduction The tradeoff between strong security and scalability (the consensus protocol blockchain systems have to rely on is scalable poorly)\non hardware aspect -\u0026gt; \u0026ldquo;trusted hardware has not been demonstrated on data-intensive blockchain workloads\u0026rdquo;\nsharding -\u0026gt; divide the blockchain network into small committees to reduce the overhead of consensus protocols\nThis paper extend sharding to permissioned blockchian systems\nBFT consensus protocols in trusted execution environment(TEE) Leveraing trusted execution environment to eliminate equivocation(provide different values to its neighbors) in the Byzantine failure model -\u0026gt; achieve higher fault tolerance with the same number of nodes [(n-1)/3 - \u0026gt; (n-1)/2].\nNot necessary to understand too many details\nEfficient shard formation protocol Leverage the TEE to design an efficient and secure shard formation protocol -\u0026gt; implement a trusted randomness beacon inside the TEE to generate unbiased random values in a distributed setting\nThe nodes derive their committee assignment by computing a random permutation pi [1 : N] seeded by rnd. pi is then divided into approximately equally-sized chunks, each of which represents the members in one committee. To exploit TEEs to efficiently obtain rnd. Each new epoch correspondings to a new node-to-committee assignment, nodes invoke the enclave with an epoch number e to generate two random values q and rnd. If and only if q = 0. \u0026lt;e,rnd\u0026gt; is broadcasted to the network. After a time theta, nodes lock in the loweast rnd they receive for current epoch e, then use it to compute the committee assignment.\nNot necessary to understand too many details (Committee size, Shard Reconfiguration)\nUTXO transactions Consists of a list of inputs, and a list of outputs. All the inputs must be the outputs of previous transactions that are unspent. The outputs of the transaction are new, unspent coins. (Given a transaction, its inputs are unspent and the sum of the outputs is not greater than that of the inputs, if two transactions consume the same unspent coins, only one is accepted)\nDistributed transactions!!! RapidChain exploites UTXO model to achieve atomicity but can not achieve isolation. And it also fails to work for non-UTXO distributed transactions, because it violates both atomocity and isolation.\nOmniLedger achieves safety for the UTXO model but remain the liveness issue.\nThe design of this paper:\nDesign a distributed transaction protocol that achieves safety for general blockchain transactions (non-UTXO) and liveness against malicious coorinators\nSafety: two-phase commit (2PC) and two-phase locking (2PL)\nLiveness: To guard against a malicious coordinator -\u0026gt; BFT reference committee serve as a coordinator\nThe BFT reference committee is also a shard which formulated by a certain number of nodes.\nThe client initiates a transaction tx by sending BeginTX request to the reference committee.\nPrepare: Once R has executed the BeginTx request, in other words, the quorum of nodes in the R have reached the consensus on this request. it enters \u0026ldquo;Started\u0026rdquo; state. Nodes in R then send PrepareTx requests to the transaction committees(transaction shard). The tx-committee will wait for a quorum of matching PrepareTx to ensure that BeginTx has been executed in R. The each tx-committee executes the PrepareTx. If consensus is reached that tx can be committed, which requires that tx can obtain all of its locks I am really comfused about this statement???), the nodes within the committee send out PrepareOK messages.\nPre-Commit: When entering “Started” state, R initializes a counter c with the number of tx-committees involved in tx:\nreceiving the quorum of matching responses from a tx-committee it will maintain the same state or enter a new state depend on the state machine input (PrepareOK or PrepareNotOK). (I am really comfused about how to regard a committee as a state machine!!! How keep the consistancy between nodes? Which node in the committee to deciede there is a quorum of matching response?)\nCommit: Once R has entered \u0026ldquo;Committed\u0026rdquo; state, the nodes in R send out CommitTx or AbortTx message to tx-committees. As same as before, the latter wait for a quorum of matching messages from R before executing the corresponding commit or abort operation.\n2PC and 2PL 2PC (used for consistency and isolation in stand-alone transactions): Two-phase commit is an algorithm for achieving atomic transaction commit across multiple nodes \u0026ndash; to ensure that either all nodes commit or all nodes abort.\n2PL (used for distributed transactions): provides serializable isolation\nGrowing: request locks\nShrinking: free locks\ndatabases often use an enhanced version of S(trong)S(trict)2PL, which is a little different compared to 2PL: the shrinking phase, which can only release the lock after the transaction is over, completely eliminates the uncommitted data of the transaction from being read.\nHow to handle dead-lock?\nDeadlock detection: database system draw the wait-for graph, dead-lock happens if there is a ring.\nDeadlock prevention: as requesting a lock that is already held, the database system kills one of the transactions to prevent deadlocks (generally the longer the transaction lasts, the higher the priority of the reservation). This prevention method does not require a waits-for graph, but increases the rate at which transactions are killed.\nReference [1] Towards Scaling Blockchain Systems via Sharding (arxiv.org)\n[2] 区块链相关论文研读7：通过分片（Sharding）扩展区块链 - 知乎 (zhihu.com)\n[3] Introduction to two-phase commit, Don\u0026rsquo;t confuse 2PC and 2PL (ebrary.net)\n[4] 一篇讲透如何理解数据库并发控制（纯干货） - 知乎 (zhihu.com)\n","permalink":"/posts/read/sharding/","summary":"Abstract \u0026ldquo;Scaling blockchain systems under general workloads remains an open question\u0026rdquo;. The challenges of scaling are different between databasebases and blockchain since they have different failure models. The major contribution of this paper: Enhance the performance of Byzantine consensus protocols -\u0026gt; inprove the individual shard\u0026rsquo;s throughput. Design an efficient shard formation protocol -\u0026gt; leverage a trsted random beacon to securely assign nodes into shards. Design a general distributed transaction protocol","title":"Towards Scaling Blockchain Systems via Sharding"}]